
[ИГРАЕТ МУЗЫКА] ДЭВИД ДЖ. МАЛАН: Хорошо. Это CS50, введение Гарвардского университета в интеллектуальные предприятия информатики и искусства программирования. И обычно мы бы все вместе были здесь, в кампусе, в этом прекрасном Театре Сандерса. Конечно, в этом году все немного по-другому, по нескольким причинам. Но вместо этого мы здесь, в Драматическом центре Леба Гарвардского университета. Благодаря нашим друзьям в сотрудничестве с Американским репертуарным театром, у нас есть это новое пространство, включая даже такие удобства, как магазин реквизита в задней части здания, где мы работали с удивительно талантливой командой в течение лета, чтобы подготовиться к этому. семестр и CS50. И поэтому я полагаю, что по пути у нас будут несколько новых и улучшенных демонстраций. Так что спасибо нашим хозяевам, Американскому репертуарному театру.

Теперь мы хотели вызвать воспоминания, по крайней мере, или некоторые образы самого кампуса, особенно для многих из вас, кто не мог лично присутствовать здесь в этом семестре. Итак, мы зашли в архив Гарварда, где среди их коллекций была эта акварель, написанная аспирантом Гарварда более 200 лет назад в 1794 году. Джонатан Фишер, сидевший на том, что сейчас является Гарвардской площадью, разглядывал некоторые из них. самые ранние здания кампуса Гарварда. И благодаря технологиям мы взяли относительно небольшую акварель, которую этот аспирант нарисовал около 200 лет назад, и теперь украшают сцену здесь, в Драматическом центре Леба.

Итак, если вы не знакомы, у нас есть Холден-Чапел здесь слева, Холлис-Холл справа от него, который является одним из студенческих общежитий в Гарвард-Ярде, Гарвард-Холл, который является одним из учебных корпусов в кампусе, а затем Массачусетс-Холл, где оба сначала лет и президент Гарварда живут и работают соответственно. 

Итак, добро пожаловать в CS50. И я могу сказать, что не так давно, но, тем не менее, кажется, довольно давно, лет 20 назад, я ходил в тот же класс. Но, как вы знаете, у меня самого были некоторые опасения, когда дело доходило до изучения CS50, когда дело доходило до изучения информатики. Потому что это была очень незнакомая область. Когда я поступил в колледж, я пошел по пути, придерживаясь своей зоны комфорта, изучая правительство на раннем этапе, думая, что стану специализироваться или сконцентрируюсь на правительстве.

И только когда я набрался смелости делать покупки, то есть посидеть в этом классе CS50, я понял, что домашнее задание действительно может быть забавным. И я обнаружил, что информатика и CS50 не связаны с программированием как таковым, хотя многие из нас так воспринимают это в старшей школе, будь то мы или наши одноклассники, посещающие занятия. Но на самом деле речь идет о решении проблем. И поэтому он очень применим не только к информатике и инженерным наукам, но и к искусству, гуманитарным наукам, социальным наукам, наукам и не только.

И поэтому, если вы чувствуете себя немного неудобно при мысли о посещении такого курса, как CS50, знайте, что почти каждый год почти две трети студентов, изучающих CS50, никогда раньше не посещали курсы информатики. Так что если вы посмотрите вверх, вниз, влево, вправо, прямо сейчас, шансы больше, чем у многих одноклассников, которые присоединятся к вам сегодня, находятся в очень похожем положении. Вы действительно в очень хорошей компании.

И что в конечном итоге важно и в CS50, мы подчеркиваем, как и в программе, что в этом курсе в конечном итоге имеет значение не столько то, где вы закончите по отношению к своим одноклассникам, сколько то, где вы закончите по отношению к себе, когда вы начали. В самом деле, принятие во внимание того, где вы сейчас находитесь, возможно, без предшествующего опыта, и рассмотрение того, где вы будете всего через три или около того месяцев, в конечном итоге должно быть мерой вашего собственного успеха.

Итак, с этой целью мы начнем с этого класса, запрограммировав кое-что из прошлого. Здесь изображение Super Mario Brothers и пирамиды, на которую персонаж должен подняться. Мы воссоздадим часть этой игры, хоть и с использованием текста, иначе известного как ASCII-арт, но мы сделаем это примерно за вторую неделю курса. Так что это будет одна из первых программ, которые вы напишете. А затем перемотайте вперед всего несколько наборов задач или заданий по программированию позже или через несколько недель, и вы создадите то, что мы называем CS50 Finance, ваше собственное веб-приложение, которое будет работать в Интернете, практически реальное котировки акций стороннего сервиса, позволяющие вашим собственным пользователям входить в систему и регистрироваться, чтобы покупать и продавать акции, так сказать, с использованием виртуальной валюты.

Итак, в течение нескольких месяцев класса вы действительно перейдете от построения пирамиды в Марио к созданию собственного веб-приложения и многому другому, после чего вы получите окончательный опыт курса, который станет вашим собственным финальным проектом.

Но что такое информатика? Что мы думали, что будем делать в эту нулевую неделю, самую первую неделю занятий, - это точно подумать, что значит решать проблемы. И позвольте мне предположить, что это информатика. Это решение проблемы. У вас есть ввод, то есть проблема, которую вы волнуете, которую вы хотите решить, и вы заботитесь о решении этой проблемы, что является так называемым выходом. А между этим вводом и выводом находится своего рода черный ящик, внутри которого происходит волшебство, волшебство, которое вы в конечном итоге сможете использовать и заставить компьютеры решать проблемы за вас. В конечном итоге внутри этого черного ящика будет код, который вы напишете.

Но для того, чтобы начать это делать, нам всем нужно договориться о том, как мы собираемся представлять эти входы и выходы. Мы все вроде как должны говорить на одном языке, так сказать. И поэтому нам нужно договориться, как эти вклады будут представлены. Итак, как мы обычно представляем информацию?

Что ж, может быть, самое простое, что можно сделать на самом первом занятии, вне зависимости от того, онлайн ли мы или лично, - это проверить посещаемость или подсчитать количество людей в аудитории. И поэтому вы можете сделать этот олдскульный стиль на своих руках, чтобы изобразить каждого человека в комнате с поднятым на руках пальцем. То, как мы можем представить информацию, сводится к очень простым цифрам на вашей руке. Конечно, с этой рукой нельзя рассчитывать очень высоко. И на самом деле есть причудливое слово для обозначения того, что мы делаем, старая школа, и это унарная запись - uno, подразумевая, что один или один палец вверх или вниз. И так можно считать, казалось бы, до пяти. И, конечно, если я возьму вторую руку, я смогу подняться до 10, и тогда все станет немного сложнее.

Но это система представления информации, и она довольно универсальна, особенно когда мы все довольно молоды. Но мы с вами склонны использовать более полезную систему. Не только цифры на руке, но и другие виды цифр. А именно десятичные цифры, которые мы с тобой знаем. Итак, числа, которые иначе более технически называются основанием 10 - и это просто причудливый способ описания того факта, что есть 10 цифр, которые вы и я, как люди, действительно обычно обычно используем. Эти цифры, конечно, от нуля до девяти, и, используя эти несколько цифр, мы можем ставить числа, такие как от нуля до девяти, а также 10, 11 и 12, и как можно выше, используя все еще несколько цифр.

Но компьютеры на самом деле не говорят на том же языке, что и мы. В каком-то смысле они намного проще, чем мы, люди, хотя кажутся такими сложными или изощренными и, безусловно, такими быстрыми. В конце концов, это все устройства, созданные руками человека, и они относительно просты по своей сути. Фактически, даже если вы не совсем понимаете, что говорите, но хотя бы слышали, что это так, на каком языке вы понимаете, что компьютеры говорят? На каком языке говорят компьютеры, если не на той системе, которую мы с вами используем, от нулей до девяток или десятичных дробей? 

Брайан, можно было бы посмотреть, кто на это ответит? Какую систему используют компьютеры, насколько вы слышали, независимо от того, проходили ли вы раньше уроки CS? Кейт, мы можем сначала пойти к тебе? 

АУДИТОРИЯ: Ага. Компьютеры используют двоичный код.

ДЭВИД ДЖ. МАЛАН: Двоичный. А можно немного уточнить? Что вы имеете в виду под двоичным кодом? 

АУДИТОРИЯ: Это нули и единицы. Так, например, в то время как мы используем от нуля до девяти для основы 10, они используют от нуля до единицы для основы 2. 

ДЭВИД ДЖ. МАЛАН: Да, именно так. Итак, компьютеры используют так называемую двоичную систему, где двойка подразумевает двойку. И они действительно используют только, как отмечает Кейт, ноль и единицу, две цифры. Так что, с одной стороны, это на самом деле очень обнадеживает, потому что, вау, это на самом деле довольно простая система, если мы используем только две из этих цифр. Но, конечно, если у вас есть только две цифры, как мы собираемся представить число два, три, четыре или любое гораздо большее число? Это почти похоже на шаг назад.

Но на самом деле это не так. И оказывается, что эта так называемая система, или основание 2 - два, потому что в словаре есть две цифры, иначе известная, как говорит Кейт, как двоичная - использует только нули и единицы, и оказывается, что здесь есть другая номенклатура. мы можем выбросить. Эти нули и единицы иначе называются битами. А биты на самом деле происходят только из двух слов, двоичных цифр. Двоичный, подразумевающий две возможности, цифры, просто символы на экране. Итак, двоичные цифры, или иначе известные как биты. И компьютеры говорят в двоичном формате, используя эти вещи, называемые битами.

Но что это значит и почему? Например, почему они несколько десятилетий назад не изобрели компьютеры, которые используют просто от нуля до девяти, вместо того, чтобы придумать совершенно новую систему, о которой мы должны думать, не говоря уже о том, чтобы говорить? Что ж, в конце концов, что компьютеры используют в качестве входных данных? На самом деле просто электричество. Вероятно, единственное, что мы делаем каждый день или каждые пару дней с нашим ноутбуком, настольным компьютером или телефоном, - это либо убедиться, что он все еще подключен, либо подключить его, чтобы зарядить. Итак, в наши дни единственным физическим входом в наши устройства является электричество в той или иной форме.

И нам не нужно вдаваться в нюансы того, что такое электричество, но я думаю, что речь идет об электронах, протекающих в устройство, чтобы зарядить его. Поэтому для наших целей достаточно знать, что есть физический ввод в устройство, в эти компьютеры и телефоны, которые мы используем. Но это все. Итак, если мы воспользуемся этим электричеством, возможно, мы сможем начать с его помощью представлять информацию.

Например, вот лампочка, этот старый призрачный свет в театре, который сейчас выключен. Но есть возможность включения. Нам просто нужно включить его или включить переключатель. И если это так, то что действительно очень убедительно в метафоре использования света, так это то, что прямо сейчас эта лампочка в настоящее время выключена, но как только я разрешаю течь электричеству, например, подключив его или, возможно, нажав выключатель, теперь это , конечно, на. И если я отключу его или снова поверну выключателем, он выключится. Или, если я снова подключу его, он включен.

Смысл этой очень простой идеи состоит в том, что мы можем взять физическое устройство, например, одиночную лампочку, и, подключив или отключив его, мы можем представлять информацию. Что я только что сделал? Я изобразил, что лампочка выключена или включена, но мы можем просто выключить и включить что-нибудь еще. Мы можем называть их нулями и единицами. 

Итак, это действительно зародыш идеи, которая подарила нам компьютеры, а вместе с ними и использование ими двоичной системы. Если, в конце концов, все, что у них есть, это физический ввод в виде электричества, что ж, давайте просто воспользуемся этим, чтобы использовать и отслеживать информацию. Давайте сохраним немного электричества, когда мы хотим представить единицу, и давайте отпустим это электричество в некотором смысле, когда мы хотим вместо этого представить ноль.

И потому, что ввод в компьютеры очень прост, он дает нам нули и единицы, которые мы сейчас используем. Но мы, кажется, сами создали себе проблему. Если у нас есть только одна лампочка или один выключатель, если он выключен, он может быть нулевым, если он включен, может быть единицей, но как я могу считать больше единицы? Эта проблема все еще остается фундаментальной. 

Ну, конечно, я мог бы использовать больше лампочек. Итак, позвольте мне спросить об этом. Если бы мы использовали три лампочки, насколько высоко мы могли бы сосчитать? Итак, с одной лампочкой мы можем сосчитать от нуля до единицы, две возможности. Но как высоко мы можем рассчитывать с тремя лампочками? Позвольте мне задать этот вопрос здесь, на экране. Через мгновение вы увидите на своей стороне именно этот вопрос, на который вы сможете ответить на своем устройстве. Как высоко вы можете считать с тремя лампочками?

Поэтому вместо одного я даю вам три, каждый из которых может быть включен или выключен. Насколько высоко мы можем считать? Итак, вы увидите здесь на экране поступающие ответы. Многие люди думают, что 60 с лишним процентов, что это восемь, - это самый высокий показатель, который вы можете сосчитать. Многие из вас думают, что их семь, а некоторые также думают, что их может быть три или два. Так что это действительно интересный диапазон ответов. И посмотрим, что может быть на самом деле.

Что ж, позвольте мне сократить здесь до трех настоящих лампочек, все из которых выключены. И я думаю, что наиболее наивно, если бы мы включили эти лампочки, если они в настоящее время равны нулю, очевидно, я мог бы включить одну, и мы могли бы назвать ее единицей. Затем я мог бы включить вторую и назвать ее двумя, включить третью, и теперь, когда включены все три, мы могли бы сказать, что теперь мы представляем три. Но мы пока еще недостаточно умны, если только считать до трех. Потому что в этой истории я просто включаю их слева направо.

Но что, если бы мы были немного умнее? Может быть, мы включим их справа налево, а может, мы как бы переставили их в разные стороны? То есть мы приняли во внимание не только количество включенных лампочек или количество пальцев в воздухе, но и схему включения и выключения лампочек, которую мы создали. Так что давайте просто посчитаем это. Так что позвольте мне несколько систематически включать некоторые из этих лампочек здесь, хотя и виртуально.

Здесь может быть один, здесь может быть два, здесь может быть три. Но тогда мы вроде как закончили с этой историей. Так как мы можем сделать это немного лучше? Что ж, начнем снова с нуля. Вот может быть один. Почему бы нам не назвать это двумя? Почему бы нам не назвать это тройкой? Почему бы нам не назвать эту четверку? Назовите это пять, шесть и семь. Хорошо, если вы не совсем поняли, по какому образцу я следовал, но поверьте мне на слово, это был уникальный узор из лампочек, всего восемь раз. Я начал с выключения, выключения, выключения, а закончил во включении, включении, включении.

Но по пути их действительно было восемь. Но как высоко я могу считать? Ну, это как бы зависит от того, с какого числа вы начинаете считать, и, как мы до сих пор это делали, компьютерные ученые делают все время. Ученые-информатики и, в свою очередь, компьютерные программы обычно начинают отсчет с нуля просто потому, что это имеет смысл, потому что, когда все выключено, вы могли бы также назвать это нулем.

Итак, если мы начнем считать с нуля и у нас будет восемь возможных паттернов, которые мы только что видели наглядно, то это позволит нам считать до семи. Итак, от нуля до семи, так что семь - это максимальное значение, которое мы можем сосчитать с тремя лампочками. Итак, те из вас, кто предлагает семь ответов, 36% из вас действительно были правы. 57% из вас, которые сказали, что восемь, верны, если предположить, что мы начинаем считать с одного, и это нормально. Но, по крайней мере, сейчас в компьютерном мире мы обычно по соглашению начинаем считать с нуля. Но вы правильно сказали, что таких возможностей восемь.

Хорошо, хорошо, это все хорошо и хорошо представлять вещи с узорами из лампочек. Но как нам теперь добраться до нулей и единиц, которые на самом деле использует компьютер? Потому что то, что внутри компьютера, в конце концов, - это не лампочки, а крошечные, крошечные переключатели, миллионы маленьких переключателей, которые могут быть либо включены, либо единицы, либо выключены, либо ноль. Эти переключатели называются транзисторами. И в наши дни в компьютерах есть миллионы таких вещей, которые могут включаться и выключаться по-разному. Итак, если у вас есть возможность включать и выключать все эти переключатели, что ж, с чем мы все можем согласиться относительно представления, когда дело доходит до использования этих переключателей? Как мы будем представлять с ними информацию?

Что ж, как ни странно, нам действительно не нужно много думать или отказываться от наших очень комфортных детских корней. Если мы рассмотрим на мгновение не только ноль и единицу, но и всю десятичную систему, от нуля до девяти, с которой вы и я начали свой день сегодня. Как работает эта система? Что ж, здесь на экране 123. Так что да, вы, наверное, думаете, что это сто двадцать три, но не совсем. Все, что я показал на экране, - это комбинация символов, 123 или трех цифр. И все мы, наверное, инстинктивно просто говорим, очевидно, что это сто двадцать три. Но, наверное, прошли годы с тех пор, как вы задумались, почему это сто двадцать три.

Что ж, давайте рассмотрим, что представляет собой каждая из этих цифр или символов. Если вы похожи на меня, вы выросли, узнав, что самая правая цифра - это разряда единиц, средняя - разряда десятков, а левая - разряда сотен. Итак, как нам перейти от этих трех символов или цифр, 123, к математической идее, которую мы знаем как сто двадцать три? Что ж, в наши дни все мы мгновенно сделали 100 умножить на 1 плюс 10 умножить на 2 плюс 1 умножить на 3, что, конечно, всего лишь 100 плюс 20 плюс 3, или математическое значение, которое мы все знаем как сто двадцать три. Итак, небольшой круговой аргумент, но просто чтобы напомнить нам, как мы добрались от 123 до ста двадцати трех.

Что ж, оказывается, что в мире компьютеров система, которую они используют, в основном такая же. Единственная разница в том, что компьютеры имеют доступ только к нулям и единицам, а не к нулям и девяткам. Итак, если мы рассмотрим сейчас абстрактно, здесь представлены только три возможных цифры, давайте на мгновение рассмотрим, почему в этих столбцах есть места, где единица, 10, 100 и так далее. Ну почему так?

Что ж, на самом деле была закономерность, и она просто связана с показателями или полномочиями. Таким образом, технически крайний правый столбец, если мы действительно вникаем в сорняки, равен 10 в нулевой степени, что, если вы помните, просто означает единицу, 10 в первой степени, что всего лишь 10, и 10 во второй степени, или 10 в квадрате - это 100. Но что интересно в представлении его таким образом, так это то, что выскакивает, что задействовано 10. Там 10 цифр, от нуля до девяти, поэтому в столбцах используется основание из 10.

Так что, возможно, теперь вы можете даже опередить меня, учитывая, что если в двоичной системе, которую используют компьютеры, у вас есть только две цифры, ноль и единицы, то единственное, что изменится, - это значение этих столбцов. . Теперь у нас есть единицы, потому что 2 до нуля - это единица, но затем у нас есть 2 для первого, 2 для второго и так далее. 

И, конечно же, если мы просто посчитаем, что в мире двоичного кода, который используют компьютеры, у нас есть разряды единиц, разрядов двоек, разрядов четверок и так далее. А теперь все готово. Несмотря на то, что теперь мы должны думать в другой базовой системе, теперь мы можем начать считать более правильно. А теперь мы можем отойти от метафоры лампочек и считать, что если все эти лампочки выключены, мы снова просто начнем думать об этих вещах как о нулях.

Таким образом, это будет набор символов или цифр, равный 000 в двоичном формате. Но в нашем человеческом мире мысленная математика, которую вы, вероятно, сделали бы сейчас мгновенно после сегодняшнего дня, была бы, ну, очевидно, что это, очевидно, 4 умножить на 0 плюс 2 умножить на 0 плюс 1 умножить на 0, или, конечно, ноль в десятичной системе. Но как, например, компьютер представляет номер один? Ну, он просто изменит этот крайний правый бит с нуля на единицу, или, говоря более метафорически, он включит этот переключатель и зажжет эту крайнюю правую лампочку, как я делал раньше.

Как мне представить двоих? В двоичном формате это будет 010. Как мне представить троих? Вот в чем мы собираемся отличиться. Теперь я включаю два из этих переключателей, потому что мне нужно что-то на месте двоек и место единиц, чтобы получить математически три. Затем, если мы пойдем дальше и выберем - сосчитайте до четырех, это будет 100. Если я хочу сосчитать до пяти, это будет 101, шесть - это 110, и, наконец, число семь будет будет 111. 

Таким образом, может показаться, что, используя три бита, каждый из которых может быть нулем или единицей, да, вы можете переставить их восемью различными способами. Две возможности для первого раза, два для второго, умножения на два для третьего дает нам восемь. Но согласно этой математике и интуиции начать отсчет с нуля, мы можем сосчитать всего семь.

Что ж, давайте продолжим и попробуем это испытать. Когда у нас нет, скажем, одной лампочки или трех лампочек, мы, на самом деле, имеем счастье иметь лампочек на целую сцену. Здесь сцену украшают 64 лампочки. И знаешь, что? Самнер, не могли бы мы вывести здесь случайное число на экран? Хорошо, если вы видите эти лампочки со своей точки зрения, у нас есть восемь лампочек плюс еще их связка, а все остальные выключены.

Итак, давайте продолжим и зададим вопрос. Если теперь эти лампочки представляют собой не одну лампочку, две или три, а еще несколько - в данном случае, по крайней мере, шесть лампочек, какую ценность мы на самом деле получаем? Что ж, позвольте мне продолжить и поставить вопрос на экране, который должен появиться у вас через мгновение. И теперь вы должны увидеть на своей стороне тот же вопрос. В двоичном выражении, какое число - в десятичном представлении двоичное число 110010? Какое десятичное число слева направо представляет двоичное число 110010?

Итак, здесь у нас есть подавляющий ответ. 50 - действительно правильный ответ. Почему это так? Что ж, если я перейду к физическим лампочкам, давайте на мгновение рассмотрим, каков узор на самом деле. Это место для единиц, место для двоек, четыре, восемь, 16, 32, и мы могли бы продолжить. Но это не имеет значения, потому что они все отключены. Итак, у нас есть 32 плюс 16 плюс 2, что действительно дает нам число, которое мы с вами знаем в десятичной дроби, как 50. И только представьте, как высоко мы могли бы сосчитать со всеми другими лампочками.

Все в порядке. Итак, мы начали с истории с электричеством. Затем мы перешли к числам и представлению вещей в десятичном или двоичном формате. Но мы как бы загнали себя в угол, потому что, если бы в нашем распоряжении были только переключатели или метафорические лампочки, которые мы могли бы представить как нули и единицы, казалось бы, единственное, что могут делать компьютеры, - это вычислять. То есть вести себя как калькуляторы. И на самом деле, на раннем этапе это именно то, для чего были разработаны компьютеры: действительно облегчение математических вычислений, которые в противном случае были бы довольно утомительными или невозможными для людей.

Но, конечно, то, что мы с вами используем прямо сейчас, то, что мы используем каждый день на наших телефонах, ноутбуках и настольных компьютерах, намного сложнее. Итак, давайте рассмотрим, как компьютер может представлять не только числа, но и буквы алфавита. 

Брайан, мы можем позвать кого-нибудь по этому поводу? Если вы хотите поднять виртуальную руку, как компьютер может представлять буквы такого алфавита, как английский, если, опять же, все, что у нас есть, - это переключатели? 

АУДИТОРИЯ: Мы можем назначить числа, которые мы получаем из двоичного кода, конкретным буквам алфавита.

ДЭВИД ДЖ. МАЛАН: Да. Мы можем присвоить конкретные числа в двоичном формате буквам алфавита. Казалось бы, это наш единственный вариант. Если у нас есть только возможность переставлять эти переключатели, лампочки или биты, что ж, мы все должны договориться о том, как представлять буквы одинаковым образом. Теперь, может быть, самый простой способ сделать это - знаете что? Давайте просто все согласимся, что заглавная буква А будет номером один. Итак, вы включаете одну лампочку или представляете двоичное число один. Что ж, как насчет B, мы могли бы использовать номер два. Для C мы могли бы использовать число три. D могло быть четыре и так далее. Нам всем просто нужно согласиться на такую ??нумерацию букв.

Но оказалось, что люди поступили именно так, но несколько иначе много лет назад. По причинам, которые мы не будем рассматривать сейчас, они решили, что на самом деле заглавная буква A будет представлена ??десятичным числом, которое мы с вами знаем как 65. Теперь в побитовой форме это будет выглядеть так: . Итак, это набор битов, который компьютер будет использовать для представления десятичного числа, которое мы теперь знаем как 65, и теперь компьютер будет просто помнить, какой тип программы вы используете.

в контексте текстового сообщения, электронного письма и т.п. фактически представляет собой заглавную букву A. Таким образом, шаблон тот же. Представление такое же. Но контекст отличается.

И система, которую люди придумали много лет назад, которая отображает 65 в A, 66 в B, 67 в C, называется ASCII, Американский стандартный код для обмена информацией. И это просто означает, что существует четко определенное сопоставление, которое несколько десятилетий назад решила группа людей, чтобы сопоставить буквы алфавита - в данном случае английского - с числами, начинающимися с 65. И есть целое сопоставление, также для знаков препинания, строчных букв и т. д.

Учитывая это, предположим, что вы действительно получили текстовое сообщение, содержащее набор битов или, на самом деле, просто последовательность десятичных чисел, которые оказались такими. 72, 73, 33. Предположим, вы получили текстовое сообщение, содержащее эти цифры. 72, 73, 33. Какое сообщение вы могли только что получить? Позвольте мне продолжить и открыть здесь сокращенную таблицу, чтобы точно определить, какое сообщение вы получили. 72, 73, 33. 

И Самнер, не могли бы мы пойти дальше и бросить это же слово из трех букв на свет? Если вы хотите увидеть это в побитовой форме, так сказать, теперь оно появится и здесь, на этих лампочках. Что это за образец? Лэнхэм, мы можем пойти к тебе? 

АУДИТОРИЯ: Это было бы HI с восклицательным знаком, верно?

ДЭВИД ДЖ. МАЛАН: Да, это действительно привет с восклицательным знаком. Оглядываясь назад, наверное, довольно легко понять, что да, 72 и 73 были H и I соответственно. Но Лэнхэм также обратил внимание на восклицательный знак, которого нет на этой диаграмме, но для точек точка-точка существует четко определенное сопоставление для всех букв алфавита, которые могут нас заинтересовать. И поэтому HI, возможно, более очевиден, чем другой. Это 33, нам нужна диаграмма побольше.

И поэтому, если вы сейчас зайдете на своих компьютерах на asciichart.com, asciichart.com, вы увидите что-то вроде этого. Хотя вы также можете просто погуглить ASCII в целом и получить копии той же диаграммы. Вы увидите, что H действительно 72, I действительно 73, но если мы посмотрим налево, 33, по-видимому, является восклицательным знаком. И вы узнаете это, только посмотрев его или просто запомнив. Но компьютеры, которые мы с вами используем, и телефоны, которые мы с вами используем, внутренне знают об этом. Это действительно то, как они запрограммированы.

Но оказывается также, что мы должны учитывать, сколько нулей и единиц мы используем сейчас для представления 72, 73 и 33. Итак, давайте в последний раз взглянем на двоичное представление, которое, согласно лампочки, вот эти узоры из битов. Поэтому, когда вы получаете текстовое сообщение от друга со словами «Привет!» Привет, восклицательный знак, написанный заглавными буквами, технически вы получаете набор битов, какую-то частоту, если это беспроводная связь, которая представляет этот набор битов.

И, как правило, современные компьютеры используют восемь битов для представления каждого из этих символов. Когда ASCII только появился, они обычно использовали семь из соображений эффективности, потому что тогда пространство было дорого. Но здесь мы использовали восемь, и, действительно, сейчас это норма, когда речь идет о представлении символов в количестве, кратном восьми. Итак, у нас восемь бит здесь, восемь бит здесь, восемь бит здесь, что означает получение сообщения HI! вы отправляете или получаете всего 24 бита.

Откровенно говоря, биты - не очень полезная единица измерения, как правило, потому что они такие маленькие. Просто ноль или один. Но каждый из этих восьмибитных шаблонов на самом деле имеет словарное слово, если хотите, то есть байты. И, скорее всего, все мы использовали этот термин в каком-то контексте, но обычно в контексте мегабайт или даже гигабайт. Действительно, когда вы говорите о размерах ваших файлов в наши дни, вы говорите в байтах в той или иной форме, миллионах или миллиардах байтов. Но каждый из этих байтов представляет собой набор из восьми нулей и единиц.

Фактически, если в нашем распоряжении 64 лампочки, получается 64, разделенные на 8. Это восемь символов. Таким образом, может показаться, что на этом этапе мы могли бы записать даже восьмибуквенное слово - если, Самнер, мы могли бы использовать случайное восьмибуквенное слово, которое мы будем использовать сейчас, - теперь вы можете писать по буквам слева направо. справа, слева направо, восьмибуквенное слово, использующее систему, известную как ASCII.

Но, конечно, мы здесь немного предвзято, поскольку ASCII - это американский стандартный код для обмена информацией. И на типичной клавиатуре американского английского языка, конечно же, больше символов, чем прописных букв, например, от A до H и I. Есть также некоторые знаки препинания и некоторые цифры, но их также немного не хватает. И любой из вас, кто находится в другом месте в мире, скорее всего, сочтет использование такой клавиатуры особенно ограничивающим или разочаровывающим. Это почему? Чего, кажется, не хватает в ASCII? Чего, кажется, не хватает в ASCII?

Что ж, позвольте мне задать еще один вопрос. Если мы действительно используем ASCII и поэтому даем себе восемь бит или один байт, сколько различных символов мы потенциально можем отобразить, фактически представить? Итак, теперь вы должны увидеть этот вопрос на своем экране. Сколько символов вы можете изобразить с помощью восьми битов? Сколько символов вы можете изобразить с помощью восьми битов? 

И это действительно говорит о том, сколько букв алфавита плюс знаки препинания, а также прописные и строчные буквы могут поддерживать ASCII или действительно могут ли компьютеры поддерживать? Что ж, похоже, что 72% или около того из вас думают, что ответ - 256. И действительно, вы можете представить 256 возможностей.

Почему? Вы действительно можете посчитать. Если у вас есть восемь битов, каждый из которых может быть нулем или единицей, это означает, что у вас есть две возможности для первой, умноженные на две возможности для второй, умноженные на два, умноженные на два, умноженные на два. Это бывает от 2 до восьмого или 256. Это нормально, если это не сразу очевидно, но если у вас есть восемь бит, каждое из которых может быть одним из двух значений, вы можете придумать 256 вариантов. 

Те из вас, кто вмешался, чтобы сказать, что в данном случае ответ равен 255, ошибаются только потому, что сейчас мы говорим об общем количестве шаблонов, которое действительно равно 256. Но наибольшее значение, которое мы могли бы представить с помощью восьми бит или восемь лампочек, это действительно может показаться 255. И это из-за всех различных паттернов, которые мы можем переставлять.

Но позвольте мне сейчас открыть вопрос аудитории. Почему американская английская клавиатура может быть особенно ограничивающей, и, в свою очередь, почему ASCII действительно не совсем подходит, когда дело доходит до представления человеческого языка, даже если это то, с чего начали компьютеры много лет назад? Чего не хватает в ASCII? Почему 256 возможных вариантов может быть недостаточно? 

Кевин, мы можем пойти к тебе? 

АУДИТОРИЯ: Конечно. Я имею в виду, во-первых, отсутствие множества акцентов в других языках. Но если вы просто рассмотрите, например, азиатские языки, их намного больше, чем 256 символов.

ДЭВИД ДЖ. МАЛАН: Совершенно верно. Таким образом, нам не хватает акцентированных символов, которые могут вам понадобиться в некоторых языках, нам также не хватает символов, которые могут вам понадобиться в азиатских языках, таких как арабский и т. П. Есть намного больше символов, которые мы, люди, используем для общения в печатном и электронном виде, чем 256. Английский язык, мы можем обойтись без этой клавиатуры, но ни разу мы не введем такие вещи, как эти символы, не говоря уже о других символах.

И оказывается, что есть и другие вещи, которые мы, люди, любим говорить в наши дни и выражать с помощью персонажей, которые вошли в моду, а именно эти вещи. Скорее всего, когда-нибудь сегодня вы отправили или получили одну из этих вещей, также известных как смайлики. Теперь, несмотря на то, что эти смайлики выглядят как картинки, они выглядят как изображения - и они, технически, - способ, которым они реализованы в компьютерах, на самом деле представляет собой образцы нулей и единиц. На самом деле это просто символы алфавита, алфавита смайликов. То есть есть некоторый узор из нулей и единиц, который представляет каждое из этих лиц, а также многие другие смайлики, которые существуют в настоящее время.

И это потому, что мир за годы перешел от ASCII, который использовал только семь, а в некотором смысле, восемь битов для представления всех возможных символов, к использованию восьми, 16, 24 или даже 32. В настоящее время Bits существует система под названием Unicode, которую придумали люди, которая поддерживает не только английский, но и все человеческие языки, является желательной целью, как в печатном, так и в электронном виде.

И в дополнение к этому, это означает, что мы можем представлять такие вещи. Итак, это так называемое лицо со слезами радости. И это лицо слез радости, по состоянию на прошлый год, было самым популярным смайликом, отправляемым через текстовые сообщения, электронные письма, социальные сети и тому подобное. Но, в конце концов, все, что вы получаете, - это, как бы, клавиша на клавиатуре. Так что, на самом деле, вы даже не узнаете этого, взглянув на это. Но на самом деле десятичное число, представляющее это лицо со слезами радости, оказывается 128 514.

Итак, по мнению Кевина, для представления не только определенных человеческих языков, но, конечно, этих смайликов, нам нужно более 256 символов, чтобы мы могли использовать не только восемь бит, но и 16, или 24, или 32. Сейчас это огромное количество возможностей. Фактически, сейчас, чтобы по-настоящему получить удовольствие от этих вещей, если вы получите это лицо со слезами радости или отправите его, вы технически просто отправляете шаблон битов, который выглядит следующим образом. Это все, что происходит под капотом каждый раз, когда вы используете эти вещи.

Все в порядке. Итак, мы снова начали с электричества. Затем мы представили числа. Теперь у нас есть возможность представлять буквы и даже эмоции в виде смайликов. Что еще там есть? Что ж, сами смайлы, конечно, по крайней мере те, на которые мы смотрели, по своей природе являются графическими. Возникает вопрос: как компьютер представляет такие вещи, как цвет? Мол, на этом лице со слезами радости было много желтого. Так как же желтый или любой другой цвет представлен в компьютере?

Что ж, позвольте мне еще раз спросить публику. Если все, что у вас есть в вашем распоряжении, - это биты, нули и единицы, и мы, как люди, должны договориться о том, как представлять цвета, что может быть одной из возможностей? Это не должен быть ответ. Но каков может быть ваш собственный инстинкт, если вы впервые создаете это самостоятельно? Как теперь компьютер может представлять цвета? Ясмин, что ты думаешь? 

АУДИТОРИЯ: Вы хотели бы, чтобы участники были разных цветов и форм и использовали одну и ту же систему.

ДЭВИД ДЖ. МАЛАН: Да, именно так. Совершенные инстинкты. Вы просто присваиваете номера разным цветам, и все мы просто должны согласиться с тем, каким на самом деле будет это сопоставление. Оказывается, есть разные способы сделать это. И если кто-то из вас артистичен и использует Photoshop или тому подобное в цифровом формате, вы, вероятно, знакомы с такими сокращениями, как RGB, красный, зеленый, синий. Но есть и другие сокращения и другие способы реализации идеи Ясмин, когда мы просто каким-то образом сопоставляем нули и единицы с реальными цветами.

Что ж, RGB просто представляет красный, зеленый и синий. И это система, которую люди придумали много лет назад, которая говорит: знаете что? Фактически, мы можем получить любой цвет радуги, смешав некоторое количество красного, зеленого и синего света. Таким образом, возникает вопрос: как мы представляем количество красного, как мы представляем количество зеленого и как мы представляем количество синего? И у нас есть, как говорит Ясмин, биты в нашем распоряжении. Так что нам просто нужно решить, как это сделать.

Итак, предположим, мы получили набор битов: 72, 73, 33 снова, но на этот раз это не электронное письмо. Это не текстовое сообщение. Это в контексте файла, который я открыл в Photoshop. Это как если бы я открыл фотографию, которую кто-то прислал мне, и я хочу немного отредактировать, и я вижу эту комбинацию чисел или, в свою очередь, битов. Что это означает в данном случае? В контексте электронного письма или текстового сообщения это все равно ПРИВЕТ!

Но в контексте Photoshop, Instagram или всего, что ориентировано на изображения, это на самом деле будет представлять некоторое количество красного, некоторое количество зеленого, некоторое количество синего. И, как мы обнаружили ранее, общее количество возможностей, которые вы можете представить с помощью восьми битов, составляет 256. Максимальное значение, которое вы можете представить, будет 255, если мы начнем отсчет с нуля. Таким образом, каждое из этих трех чисел представляет собой число от нуля до 255. Таким образом, 72 воспринимается как среднее количество красного, 73 - как среднее количество зеленого, 33 - немного синего. И если вы объедините эти три количества цвета, восемь бит плюс восемь бит плюс восемь бит, используя в сумме 24 бита, используя первую треть для представления красноты, вторую третью - зеленую и третью третью - синюю, вы получите, как выясняется, точка, которая выглядит вот так, желтая точка.

Итак, действительно, этот смайлик, когда он отображается на экране, является результатом компьютерной интерпретации - значение 128 514 означает знание, о, это смайлик со слезами радости. Но когда дело доходит до отображения информации на экране, теперь ваш компьютер будет использовать разные шаблоны битов для управления цветами точек на экране.

И этот термин вы, возможно, уже знаете. Точки, которые мы с вами видим на экранах наших компьютеров или даже телевизоров в наши дни, называются пикселями. Это крошечные квадратики, которые представляют какой-то цвет, например, этот желтый. И вы действительно можете увидеть их в некоторых контекстах. Если я сделаю то же самое лицо со слезами радости и немного увеличу масштаб, еще немного увеличу и действительно увеличу немного больше, теперь вы действительно сможете увидеть то, что мы называем пикселизацией. И, скорее всего, вы видели это на Facebook, Instagram, где бы вы ни изменяли размер или редактировали фотографии, у которых недостаточно разрешения. Разрешение изображения - это количество пикселей или точек по горизонтали и вертикали.

Поэтому, если вы действительно увеличите масштаб изображения, вы в конечном итоге увидите эти пиксели. И это означает, что даже на этом увеличенном счастливом лице есть огромное количество желтых точек, а также множество черных, серых и коричневатых точек, которые составляют это очень красочное изображение. Итак, вы можете видеть их в этом случае, и каждая из этих точек сейчас, пиксель, как я утверждаю, использует как 24 бита или три байта.

Теперь вы можете себе представить, что на этом изображении, вероятно, есть сотни, может быть, тысячи точек, если мы уменьшим масштаб и посмотрим на все еще раз. Итак, если каждая из этих точек или пикселей составляет три байта, именно поэтому фотографии, которые мы с вами делаем, и изображения, которые мы с вами загружаем из Интернета, обычно измеряются даже не в байтах как таковых, а в килобайтах для тысяч байты или мегабайты для миллионов байтов, или, если это видеофайл, он может стать еще больше, миллиарды или гигабайты. Но это все, что происходит под капотом. Мы просто представляем информацию таким образом.

Что ж, позвольте мне задать еще один вопрос. Если мы теперь, благодаря Ясмин, представили цвета и, в свою очередь, изображения, потому что все изображение представляет собой сетку пикселей. Вы берете тот же принцип, который предложил Ясмин, когда вы представляете каждый цвет точки, и у вас есть целая группа точек, которая дает нам изображения. Как бы вы предложили компьютерам представлять видеофайлы? Опять же, даже если вы не знаете ответа, как компьютер может теперь представлять видеофайлы, опять же используя только биты в своем распоряжении? 

Кому может понравиться выставить на поле этот? Как компьютер может представить видео? Джастин, что ты думаешь? 

АУДИТОРИЯ: Я ... может просто быстро меняю прикусы? 

ДЭВИД ДЖ. МАЛАН: Просто быстро меняют прикусы. Я слышал ... не могли бы вы немного уточнить? Что вы имеете в виду под изменением прикусов?

АУДИТОРИЯ: Как быстрое изменение RGB отдельных пикселей ... 

ДЭВИД ДЖ. МАЛАН: Совершенно верно. 

АУДИТОРИЯ: - чтобы соответствовать изображению этой секунды видео или части видео. 

ДЭВИД ДЖ. МАЛАН: Прекрасно. Итак, если вы подумаете, например, о прямоугольном экране, который является вашим телефоном, или вашим ноутбуком, или вашим настольным монитором, если вы просто продолжите менять цвета этих точек один раз в секунду или целую кучу раз в секунду, мы получить иллюзию, что на экране действительно есть движение, т.е. видео. Так что на самом деле видео, в каком-то смысле, это просто целая куча изображений, по определению Ясмин, очень быстро летающих по экрану. И поэтому вы можете увидеть этот даже олдскульный стиль.

Например, позвольте мне открыть на моем экране короткое видео, которое представляет собой флипбук. Так что вы могли сделать один из них в детстве, или ваш учитель сделал, или вы видели их, по крайней мере, где-то лично. Если вы возьмете целую кучу листов бумаги и скрепите их вместе или каким-то образом скрепите их вместе, нарисуйте целую кучу картинок, которые все похожи, но немного отличаются на каждой странице, вы можете создать анимацию или, действительно, видео. 

И это все видео в чисто электронном мире. Несмотря на то, что это реализовано на бумаге, то, что происходит в компьютерном мире, на самом деле представляет собой целую последовательность изображений, пролетающих по экрану с некоторой скоростью. И это то, что на самом деле дает нам видеофайлы, которые мы с вами знаем сегодня.

И еще больше кроличьих нор, в которые мы можем спуститься. Например, как бы вы могли представить музыку? Ну, музыку можно было представить, черт возьми, по-разному. Например, если вы играете на пианино, вы можете знать, что есть ноты, такие как от A до G. Но есть также диезы, бемоль и т. Д. Но вы знаете, что? Возможно, нам просто нужно число, чтобы представить каждую из этих возможных заметок. И, возможно, мы могли бы использовать другое число, точно так же, как изображения используют несколько чисел для представления точек, мы могли бы использовать число для обозначения нот в песне, а также другое число для обозначения продолжительности этой ноты. Сколько секунд, миллисекунд или ударов вы должны услышать эту ноту.

Таким образом, вы могли бы придумать и другие формулировки, но на самом деле музыку можно квантовать в мире компьютеров только на небольшие фрагменты информации. И пока мы с вами договоримся о том, как это представить, все это работает именно так. 

И если вы когда-нибудь задумывались, почему существуют файлы JPEG, PNG, GIF, документы Word и файлы Excel и все эти разные форматы файлов или расширения файлов на компьютерах, эти расширения или форматы файлов просто представляют собой целую кучу людей, согласных, как хранить шаблоны нулей и единиц в файле, так что когда эти нули и единицы загружаются в компьютер для отображения или интерпретации, он знает, что представляют эти шаблоны. Изображения представлены немного по-другому, звук и видео представлены немного по-другому, но это '

Итак, это все, чтобы сказать, пока мы все согласны, в идеале, во всем мире, как представлять информацию, теперь мы можем представлять исходные данные для проблем и, надеюсь, решать проблемы и получать результаты. Итак, все, что остается при решении проблем или, на самом деле, информатике в целом, - это заглянуть внутрь этого черного ящика и подумать о том, как вы принимаете входные данные, будь то числа, буквы, изображения, видео, звук, и преобразовывать их в реальные решения. 

Итак, внутри этого черного ящика находится то, что мы обычно называем алгоритмами. Алгоритмы - это пошаговые инструкции по решению проблем. Им даже не нужно привлекать компьютеры. Мы, люди, можем выполнять алгоритмы, просто следуя чужим инструкциям. Если вы когда-либо готовили что-то из поваренной книги, следуя рецепту, вы выполняете алгоритм шаг за шагом.

Но в отличие от множества рецептов или в отличие от множества инструкций, которые мы, люди, даем друг другу, в компьютерах нет места двусмысленности. Алгоритмы компьютеров, когда они реализованы машинами, действительно должны быть не только правильными, чтобы вы получали нужные вам выходные данные, но и должны быть точными. Вы должны быть очень точными, потому что в отличие от людей, которые умеют читать между строк, и, да, я понимаю, что вы имеете в виду, компьютеры будут воспринимать вас буквально. 

И поэтому при программировании компьютера, то есть переводе алгоритма, пошаговых инструкций на какой-либо язык, понятный компьютеру, вы должны убедиться, что компьютер не может неверно истолковать то, что вы хотите.

Итак, давайте рассмотрим один из таких алгоритмов. Итак, на всех наших телефонах, будь то iOS, Android и т. П., У вас есть приложение для работы с контактами. И это приложение для контактов, вероятно, хранит всех ваших друзей, членов семьи и коллег, вероятно, в алфавитном порядке. Может быть, по имени, может быть, по фамилии, или как вы организовали это устройство. 

Что ж, старая школьная версия этого есть в бумажной форме, которая выглядит примерно так: телефонная книга. И внутри старой школьной телефонной книги действительно та же самая идея. Он намного больше. Это намного больше, намного больше напечатано. Но это то же самое. В обычной телефонной книге есть множество имен и номеров, отсортированных в алфавитном порядке, как в вашем собственном телефоне Android или телефоне iOS.

Итак, предположим, мы хотим решить проблему. И входом в эту проблему является не только эта телефонная книга, но и имя человека, по номеру которого нужно искать. Например, мое собственное имя. Если я хочу найти свой номер телефона или вы это сделаете, вы можете открыть эту книгу и начать искать Дэвида, например, если мы предположим, что она отсортирована по имени. Я не вижу Дэвида на первой странице, поэтому перехожу ко второй. Я себя там не вижу, поэтому перехожу к третьему. Я себя там не вижу, поэтому перехожу к четвертому. И так далее, по одной странице за раз, ища мое имя и, в свою очередь, мой номер.

Что ж, если правильность важна, позвольте мне сначала задать этот вопрос. Верен ли этот алгоритм, шаг за шагом переворачивая страницы в поисках Дэвида? Как вы думаете? В Zoom вы должны увидеть несколько значков под окном участников, помеченных как «да» и «нет». Если вы хотите пойти дальше и проголосовать виртуально, да или нет, правильный ли этот алгоритм? По одной странице, ищу себя. Не говоря уже о том, что это желтые страницы, и поэтому я не собираюсь нигде в телефонной книге, но на самом деле мы предположим, что там тоже есть люди.

Все в порядке. Похоже, алгоритм действительно правильный, но он ужасно, ужасно медленный. И это нормально, потому что одна из идей, которые мы собираемся рассмотреть в CS50 и, в свою очередь, в информатике, - это не только правильность алгоритма, но и его эффективность. Насколько хорошо разработан алгоритм? Это правильно. Это просто невероятно, невероятно утомительно и медленно. Но я найду себя.

Но, конечно, мы можем добиться большего. Вместо того чтобы искать себя по одной странице, почему бы мне не сделать одну страницу, позвольте мне сделать две, четыре, шесть, восемь, 10. Это звучит быстрее и быстрее. Я ищу себя в телефонной книге в два раза быстрее. Это правильный алгоритм? На этот раз позвольте мне подойти к кому-нибудь из аудитории. Верен ли этот алгоритм поиска чьего-либо имени на двух страницах за раз? Потому что я утверждаю, что это более эффективно. Я утверждаю, что он разработан лучше, потому что я решу проблему в два раза быстрее. Анека, что ты думаешь? 

АУДИТОРИЯ: Нет, потому что вы можете пропустить свое имя на странице. 

ДЭВИД ДЖ. МАЛАН: Да, я могу пропустить свое имя на странице. И позвольте мне задать дополнительный вопрос. Могу я это исправить? Как вы думаете, нужно ли отказываться от всего алгоритма или можно хотя бы решить эту проблему?

АУДИТОРИЯ: Думаю, какую бы страницу вы ни перевели, это поможет увидеть, например, какое там имя, и, возможно, увидеть, будет ли ваше имя перед или после. 

ДЭВИД ДЖ. МАЛАН: Хорошо. Так что это совершенно правильная интуиция. Я не думаю, что мы должны полностью жертвовать идеей ускорения этого алгоритма, двигаясь вдвое быстрее. Но, как вы предлагаете, если я зайду слишком далеко - может быть, я дойду до раздела E, который на одну букву слишком поздно - я должен по крайней мере вернуться на одну страницу назад. Потому что мне могло не повезти, и, возможно, Дэвид оказался зажат между двумя страницами, и в этот момент я мог бы пролететь мимо, добраться до конца телефонной книги, скажем, нет, Дэвида нет, а мне просто не повезло с 50 % вероятность.

Но, как вы предлагаете, я могу по крайней мере прийти в себя и условно спросить себя: «Подожди минутку, может, я просто пропустил это», и вернуться назад. Таким образом, я могу получить общее улучшение скорости, но затем, по крайней мере, исправить такую ??ошибку или ошибку. И ошибка, наш термин - в программировании ошибка - это просто ошибка в программе или, в более общем смысле, ошибка в алгоритме.

Но, честно говоря, никто из нас не собирается этого делать. Когда мы на самом деле ищем кого-то в телефонной книге, как это делают наши телефоны, они обычно не начинают сверху и идут вниз. А компьютеры делают именно то, что вы могли бы делать более интуитивно. Вероятно, они дойдут примерно до середины. Может быть, они немного отклонятся влево, если вы знаете, что D указывает на начало алфавита. Но нет, я небрежно открываю средний вид, и я нахожусь в секции М. Итак, что я знаю, когда нахожусь в разделе M об этой проблеме? 

Позвольте мне позвать еще одного человека. Я в разделе М. Что бы вы сделали сейчас как человек, приняв это как вклад в решение этой проблемы? Что я знаю о местонахождении моего имени в телефонной книге? Какое решение я могу здесь принять? Какое решение я могу принять? Кайл,

АУДИТОРИЯ: Ага. Итак, начиная с буквы М, вы знаете, что вашего имени там точно не будет. 

ДЭВИД ДЖ. МАЛАН: Да, поэтому мое имя не будет в разделе М. Но благодаря алфавитной записи телефонной книги я хоть знаю, знаете что? Я могу извлечь огромную долю из этой проблемы и разорвать ее пополам, как метафорически, так и буквально, в случае телефонной книги. И я могу буквально отбросить половину проблемы. 

Итак, если я начал с примерно 1000 страниц в этой телефонной книге или с 1000 контактов в моем телефоне, просто перейдя примерно к середине и посмотрев налево и направо, я могу решить, как вы заметили, хорошо , его нет на той странице, которую я ищу. Но я могу решить, что это слева или справа. Я знаю, что D стоит перед M. И теперь я могу пойти налево.

И вы знаете, что здесь интересно, так это то, что я могу использовать тот же самый алгоритм. Мне не нужно думать иначе. Я могу применить ту же логику, открыть середину этой половины телефона, книгу, и теперь я вижу, что я нахожусь в разделе G. Так что я все еще слишком далеко. Но опять же, я могу оторвать половину проблемы, отбросить ее, и теперь я перешел от 1000 страниц к 500 страницам на 250 страниц. Если я сделаю это снова, я могу обнаружить себя, о, я добрался до раздела C. Я могу снова разорвать задачу пополам, выбросить левую половину, и теперь у меня осталось всего 125 страниц.

Это все еще много, но, боже мой. Я перешел от 1000 до 500, от 250 до 125. Это намного быстрее, чем от 1000 до 999 до 998, и даже быстрее, чем от 1000 до 998, до 996 и 994. Оба эти алгоритма займут меня намного дольше. 

У нас есть чудесная визуализация, сделанная Брайаном, которая изображает 1024-страничную телефонную книгу с перелистыванием одной страницы за раз. И теперь мы упали до 996, 995. Я имею в виду, честно говоря, это не так уж и много поучительно. На поиск Дэвида или любого имени в телефонной книге уйдет целая вечность, если начать в таком темпе с этим алгоритмом.

Но что, если вместо этого я немного умнее и интуитивнее? И я использую интуицию, которая, вероятно, была у вас, и снова начинаю с 1024 страниц, и на этот раз разделяю и властвуй, пополам, разделяя проблему пополам? Разорвав телефонную книгу пополам, достаю всего одну страницу. И если мы действительно посчитаем, если вы начнете с более чем 1000 страниц, мне понадобится всего 10 разрывов этой телефонной книги, чтобы добраться до моего номера 949-468-2750. 

Таким образом, это означает, что третий алгоритм не только верен, как определенно был первый и второй может быть с этим исправлением ошибки, но он также намного лучше спроектирован. Это намного эффективнее. И поэтому мы можем увидеть это немного графически.

Позвольте мне продолжить и не предлагать численный анализ или что-то в этом роде. Но просто что-то вроде этого немного визуально. Итак, если у меня здесь есть ось X, которая представляет по горизонтали размер проблемы, количество страниц в телефонной книге, а по вертикали по оси Y - количество времени, необходимое для решения проблемы. Как выглядят эти алгоритмы, если мы просто как бы изобразим их на диаграмме?

Ну, первый алгоритм, изображенный здесь красным, это просто прямая линия. Угол наклона равен единице, потому что между количеством страниц и количеством времени, которое мне требуется, чтобы решить эту проблему, существует взаимосвязь один к одному. С каждой новой страницей этой телефонной книги, может быть, год за годом, если телефонная книга будет расти, мне понадобится еще один шаг, чтобы искать себя или кого-то еще, возможно, в этой телефонной книге. Если мне не повезет, и они рано появятся в телефонной книге, но еще одна страница означает еще один поворот страницы.

Второй алгоритм на самом деле лучше. Это все еще прямая линия. Так что это все еще линейная зависимость. Но на каждые две страницы в телефонной книге у меня уходит еще один шаг. Две страницы, один оборот. Две страницы, один оборот. Так что это строго лучше, чем первый алгоритм. Почему? Что ж, если мы рассмотрим это - если размер проблемы, может быть, здесь, например. Итак, если мы предположим, ради обсуждения, возможно, в телефонной книге есть такое количество страниц, обозначенных этой пунктирной линией. Ну, сколько времени потребуется второму алгоритму, чтобы найти кого-нибудь в этой телефонной книге? Это займет столько времени, верно? Где пересекаются эти две линии.

Однако, если вы используете первый алгоритм, переходя по одной странице за раз, на самом деле это займет столько времени, что буквально вдвое больше. Так что они оба правы, если предположить, что мы вернемся назад по мере необходимости, если я уйду слишком далеко от имени. Но оба они в основном одинаковы. У них такая же форма, и, честно говоря, они оба не спешили говорить и действовать. 

Третий алгоритм, если бы мы его построили на графике, имеет принципиально иное соотношение между размером проблемы и временем, необходимым для ее решения. Линия идет вверх, вверх, вверх, вверх, как и должно, потому что чем больше страниц, тем больше времени потребуется на решение, но обратите внимание, насколько медленнее она поднимается. Эта вещь почти не начинает расти, поскольку размер проблемы становится все больше и больше. И почему так,

Что ж, вот что действительно важно: предположим, что в следующем году телефонная книга по какой-то причине увеличится вдвое. Может быть, Кембридж и Олстон, штат Массачусетс, объединились в одну большую телефонную книгу, так что вместо этого теперь там 2000 с лишним страниц. Сколько еще шагов потребуется в следующем году, чтобы найти кого-то в этой телефонной книге? Один. Еще один шаг. Итак, если вы посмотрите сюда, вдоль этой зеленой линии, увеличивая размер телефонной книги вдвое, сама линия вырастет лишь немного, потому что это не имеет большого значения. С помощью этого третьего алгоритма вы решите проблему гораздо шире.

И это тоже говорит о том, что такое информатика и программирование. Использование идей, с которыми вы приходите в класс и которые вы могли бы использовать в повседневной жизни, но вы не обязательно думаете о том, как вы можете представлять проблемы, используя эти алгоритмы, и как вы могли бы перевести их на компьютерную речь. И действительно, один из способов, которым мы начнем думать об алгоритмах, - это не только их правильность, но и то, насколько хорошо они спроектированы.

И поэтому, например, здесь я намеренно пометил эти три строки n, n более 2 и логарифмическую базу 2 над n. Это просто означает, что если мы используем n как число - значит, компьютерные ученые склонны использовать n как переменную, так же как математик может сказать x, y или z, n для числа. Итак, первая красная линия - это время выполнения, количество шагов, которое может потребоваться для решения проблемы, может быть, в худшем случае, n. Если в телефонной книге n страниц, может быть, я ищу кого-то в конце телефонной книги, и мне потребуется все n шагов, чтобы их найти. 

Второй алгоритм потребует вдвое меньше шагов. Таким образом, мы выражаем это как n, деленное на 2, потому что, если мы делаем две страницы за раз, мы дойдем до конца телефонной книги - если мы ищем кого-то, чье имя начинается с Z,

Но третий алгоритм, если вы немного не разбираетесь в математике, представлен в виде логарифма с основанием 2. И это просто означает, что на этом графике зеленая линия описывает, сколько времени требуется для решения проблемы при включенном каждый проход, на каждом шаге, вы делите задачу, в данном случае, пополам. Два других алгоритма решают проблему на один-два укуса. Третий алгоритм брал на себя половину задачи за раз. И это сделало его еще более мощным.

Итак, когда дело доходит до программирования, нам нужно перевести в код эти вещи, называемые алгоритмами. Или, в данном случае, назовем это псевдокодом. И чуть позже мы сосредоточимся на реальном языке программирования, хотя и графическом. Но пока давайте просто рассмотрим некоторые конструкции или некоторые фундаментальные идеи, которые будут полезны для использования здесь, в этом классе. 

Итак, позвольте мне предложить, что то, что я действительно только что сделал устно, можно перевести в псевдокод, который похож на алгоритм, реализованный на английском языке или на любом другом вашем устном или письменном языке. Но ключ в том, что он должен быть правильным, и в идеале лучше быть точным, чтобы не было двусмысленности.

Шаг первый действительно был тем, что я сделал. Возьмите телефонную книгу. Шаг второй: откройте середину телефонной книги. Шаг третий, посмотрите на страницу. И я действительно это сделал. А теперь стало интересно. Шаг четвертый, если человек - Дэвид, в моем случае - находится на странице, что я хочу сделать? Что ж, мне, наверное, стоит позвонить этому человеку. Проблема решена. Я получил свой вывод, номер человека. 

Но есть и другая возможность, не в том случае, если человек находится на странице, а, скорее, если этот человек находится раньше в книге - и это то, что произошло мгновение назад. Если я оказался на M, но я ищу Дэвида, он находится слева, что мне тогда делать? Откройте до середины левой половины книги. И я действительно так и сделал. И я вроде как безвозмездно разорвал проблему пополам. Но алгоритмически я просто посмотрел на левую половину книги.

Что мне делать дальше? Ну, действительно, именно в этот момент я предложил, чтобы алгоритм теперь можно было просто повторять, снова и снова, и поэтому мы скажем, что вернемся к третьей строке. Почему? Итак, начиная с третьей строки, у меня есть алгоритм поиска кого-то в телефонной книге. Так уж получилось, что телефонная книга сейчас вдвое меньше. 

Но есть другой случай. Что, если этот человек будет позже в книге? Я искал не Дэвид, имя которого начинается с D, а чье-то имя в конце алфавита. Что ж, тогда, если этот человек будет позже в книге, то же самое. Откройте середину правой половины книги, а затем снова вернитесь к шагу три.

Но, наконец, есть четвертая возможность. Есть четвертая возможность. Либо человек в телефонной книге, либо он слева, либо справа, либо, честно говоря, их там просто нет. И этот последний момент, хотя и несколько тонкий, но очень важен. Скорее всего, все мы на наших Mac, ПК. Может быть, даже у телефонов был тот очень неприятный опыт, когда ваш компьютер зависает, вы получаете тупой вращающийся пляжный мяч или песочные часы, устройство зависает или просто перезагружается, вы знаете, что-то идет не так, и это как-то необъяснимо.

И вы можете подумать, что это ваша вина, но на самом деле обычно виноват программист, который написал программное обеспечение, которое вы используете на своем компьютере или устройстве. Почему? Очень часто этот программист по какой-либо причине не предвидел возможного сценария. В этом случае есть четыре сценария, но вы можете себе представить, как будто вы забываете о том факте, что, ну, может быть, Дэвида даже нет в этой телефонной книге. Но тебе лучше разобраться с этим сценарием. И когда у вас есть компьютер, который зависает, зависает, перезагружается или что-то идет не так, это довольно часто просто потому, что человек не написал код для некоторого возможного сценария.

Итак, какие фундаментальные конструкции, которые мы здесь видели, мы продолжим видеть в классе? Итак, теперь желтым цветом выделены некоторые глаголы или действия, которые мы выполняли с этой телефонной книгой. Обычно в программировании они называются функциями. Функция - это действие или глагол. Это заявление, которое заставляет компьютер что-то делать. 

Далее выделено то, что мы будем называть условиями или ветвями. Это своего рода пресловутые развилки на дорогах. Вы можете сделать то или это, или, может быть, еще что-нибудь. И у вас может быть одно решение, или два, или три, или четыре, независимо от того, какие условия имеют логический смысл. Мы назовем эти условия. Но как решить, на какую развилку выбрать дорогу? Делать ли то или это, или что-то другое? Для этого нам понадобится нечто, называемое логическими выражениями.

Логическое выражение - это просто вопрос, ответ на который - да или нет, или истина или ложь, или, откровенно говоря, один или ноль. Все это было бы эквивалентно для наших целей. Итак, человек на странице. Это вопрос «да» или «нет». Человек ранее в книге? Это тоже вопрос. Человек позже в книге - это тоже третий вопрос. Итак, если вы можете представить себе ответ да-нет, ответ истина-ложь, ответ один-ноль, это то, что дает нам такие вещи, которые называются логическими выражениями. 

И, наконец, вот эти вещи желтым цветом. Вернитесь к третьей строке. Это вызовет то, что мы назовем циклом или циклом, который является просто конструкцией программирования или принципом алгоритма, который заставляет вас делать что-то снова и снова, поэтому вам не нужно писать алгоритм из 100 строк. Вы можете написать алгоритм из 13 строк и повторно использовать его части снова и снова.

Итак, мы начнем сейчас, и мы начнем CS50 с рассмотрения реального языка программирования, который вы, возможно, использовали недавно или в детстве, известного как Scratch, который представляет собой графический язык программирования, который, хотя и может быть очень знакомым для некоторых из вас, на самом деле он представляет многие из этих основ программирования, которые мы будем использовать в качестве основы для перехода всего за одну неделю на более традиционный, более старый школьный язык, известный как C, который полностью состоит из текста и клавиатуры -на основе.

Но мы увидим на всех языках, которые мы рассмотрим в CS50, эти вещи, называемые функциями и условиями, логическими выражениями и циклами, и сегодня, буквально через мгновение, мы также увидим некоторые другие функции, которые мы описываем как переменные, мало чем отличается от x, y и z в математике, потоках, которые позволяют компьютеру, казалось бы, выполнять сразу несколько задач, событий и, кроме того, других функций.

Итак, отсюда мы переходим от псевдокода к реальному коду. И то, что вы видите на экране, - это пример языка C, на котором мы будем проводить много времени в этом семестре. Это старый школьный текстовый язык с клавиатурой, о котором я упоминал ранее. Но этот язык немного загадочен. И, конечно же, на первый взгляд, вы можете задаться вопросом, почему здесь символ решетки, угловые скобки, круглые скобки, фигурные скобки, точка с запятой, кавычки, я имею в виду, боже мой, существует так много синтаксиса того, что на экране сейчас. И вы, наверное, догадались, что делает эта программа. 

Позвольте мне быстро перейти к аудитории. Что, возможно, делает эта программа, даже если вы никогда раньше не программировали компьютер? 

АУДИТОРИЯ: Он просто выводит "привет, запятая, мир".

ДЭВИД ДЖ. МАЛАН: Совершенно верно. Он просто печатает "привет, мир". И, боже мой, посмотрите на весь синтаксис и все нажатия клавиш, которые нам приходилось набирать, чтобы заставить компьютер сделать это. И вот, по контрасту, сегодня Скретч. Мы позволим себе только сегодня взглянуть на что-то гораздо более дружелюбное, гораздо более графическое, что позволит нам изучить эти самые идеи и подготовить почву для более сложных, более традиционных языков на следующей неделе и в будущем, но в контексте, где нам не нужно беспокоиться о скобках, точках с запятой, фигурных скобках и о том, где даже эти клавиши находятся на клавиатуре.

Итак, позвольте мне представить вам Scratch, разработанный некоторыми из наших друзей по дороге здесь, в Кембридже, в Media Lab Массачусетского технологического института. Вы можете подыграть здесь дома, если хотите, на сайте scratch.mit.edu. Это веб-версия, но есть и автономная версия, если вы, как правило, не пользуетесь Интернетом. Но пользовательский интерфейс обычно выглядит так. И быстрый тур. 

Итак, здесь, на scratch.mit.edu, когда вы переходите к созданию проекта с помощью кнопки в интерфейсе, вы увидите первого Scratch, тезку программы, этого кота, который живет в этом маленьком прямоугольном мире, в котором вы можете перемещаться. вверх, вниз, влево или вправо. Но кошку можно превратить в любое количество ее персонажей или в то, что мы назовем спрайтами, их визуальные представления.

Здесь слева находятся все строительные блоки, которые поставляются со Scratch. Все программные конструкции доступны в виде кусочков головоломки. И вы заметите, что они классифицируются по цвету и описанию, и есть целая куча кусочков головоломки, которые скорее говорят о том, что они делают. И сегодня цель состоит не в том, чтобы углубляться в все эти различные кусочки головоломки, а в том, чтобы выделить некоторые из фундаментальных идей, которые возможны. 

И мы рассмотрим эти идеи в центре экрана. Через мгновение мы сможем начать перетаскивать эти части головоломки на этот большой экран и связывать их вместе, если это имеет логический смысл.

Наконец, для наиболее сложных программ мы можем создать еще больше персонажей или спрайтов, а также иметь много взаимодействий на экране. Но давайте продолжим и довольно быстро рассмотрим только один пример. Я собираюсь перейти на свой экран и, действительно, перейти на scratch.mit.edu. И ты тоже можешь подыгрывать дома. И я собираюсь нажать «Создать», чтобы попасть именно в этот интерфейс. Вам не нужно создавать учетную запись с самого начала, если вы этого не хотите. И позвольте мне начать создавать программу.

Самая первая программа, которая когда-то была написана, по преданиям, была просто тем, что Айрис предложила как «Hello World», программой, которая выводит на экран hello, world. Ну как мы можем это сделать? Что ж, я, вероятно, смогу сделать это довольно быстро, потому что я использовал интерфейс раньше, но цель для вас, если вы никогда не использовали это раньше, с первым набором задач курса или заданием по программированию, на самом деле просто получить руки пачкают, исследуют и ковыряются. И, скорее всего, идеи, которые вы ищете, в конечном итоге появятся.

И первое, что я собираюсь попробовать, это вот здесь. Это кусок пазла желтого или оранжевого цвета. Он находится в категории «События» и вызывается при нажатии зеленого флажка. Это интересно, потому что, если я перейду сюда на сцену Скретча, вы увидите, что в верхнем левом углу есть зеленый флаг, который будет означать идти, и красный знак остановки, который будет означать остановку. Так что, если я хочу, чтобы что-то произошло, когда я щелкну этот зеленый флаг, я начну с этого кусочка головоломки. 

Теперь я перейду в категорию Looks. А в категории Looks есть целая куча блоков. Но здесь мы сохраним простоту. Я собираюсь продолжить и просто сказать каноническое, как отметила Ирис, привет, запятая, мир.

Я снова уменьшу масштаб. Я перейду к Scratch здесь, и сейчас я собираюсь щелкнуть зеленый флаг. И вуаля, привет, мир. Так что это моя - и, возможно, скоро и ваша - самая первая программа, использующая на этом языке Scratch. 

Но это, конечно, не очень интересно. Впервые может быть приятно. Но это не то, что вы хотели бы играть снова и снова. Но мы можем сделать эту вещь намного более интерактивной, и мы можем начать накладывать эти строительные блоки на слои и иметь алгоритм, больше похожий на поиск в телефонной книге, который состоит из нескольких шагов.

Так что позвольте мне продолжить и остановить эту программу. И позвольте мне вместо этого немного исследовать. На этот раз позвольте мне перейти в раздел «Ощущение», в эту синюю категорию. И вы увидите здесь этот блок. Спроси, как тебя зовут, и жди. Но обратите внимание на то, как вас зовут в этом белом овале, и это означает, что я могу изменить суть вопроса, если захочу, но пока меня устраивает этот вопрос. И позвольте мне пойти дальше и сначала избавиться от этих блоков, и дать себя, когда щелкнет зеленый флаг, и на этот раз начну в разделе Sensing с вопросом, как вас зовут, и подождите.

Но обратите внимание, что это своего рода особый блок. Он поставляется со вторым блоком, так называемой переменной. Оказывается, этот кусок головоломки буквально задаст вопрос человеку, который играет в эту игру, и будет хранить ответ на этот вопрос в переменной, изображенной здесь в виде синего овала, называемого ответом. Как и в математике, x, ay или z. 

Так что же мне с этим делать? Что ж, позвольте мне снова пойти в Looks. Позвольте мне пойти поздороваться, но на этот раз знаете что? Позвольте мне продолжить и поздороваться, запятая, а затем - хорошо, позвольте мне дать себе второй блок say. Но я не хочу снова здороваться. Я собираюсь удалить это.

Но я собираюсь вернуться к Sensing и перетащить ответ. Теперь он выглядит слишком большим, но обратите внимание, если я подойду к нему, он как бы магнитно хочет соединиться. И действительно, Scratch вырастет, чтобы заполнить для меня кусочек пазла. Итак, теперь у меня есть программа, казалось бы, программа, написанная на Scratch, часть программного обеспечения, написанная на Scratch, которая собирается, когда щелкают по зеленому флажку, спрашивают, как вас зовут, и ждут - это наша функция - скажем привет - это еще одна функция - а затем он скажет ответ независимо от того, что набрал человек. 

Что ж, позвольте мне перейти в мир Скретча и щелкнуть зеленый флаг. Обратите внимание, кот спрашивает меня, как вас зовут. Я ввожу Дэвида и вхожу. Хм. Я вижу только Дэвида. Ну может я что-то не так сделал. Позвольте мне сделать это снова. Зеленый флаг, ДЭВИД, входить. Хм.

Что происходит? Это похоже на ошибку, потому что я почти уверен, что у меня есть три функции: спросить, сказать и сказать. Но мне кажется, что мне не хватает второй инструкции. Есть мысли о том, какую ошибку я сделал? Чем это можно объяснить? Натали, да? 

АУДИТОРИЯ: Значит, вы заменили вывод той же функцией.

ДЭВИД ДЖ. МАЛАН: Да. Я заменил вывод на ту же функцию. И, честно говоря, несмотря на то, что мы используем довольно простую программу Scratch, мой Mac на самом деле работает довольно быстро. И ваш ПК, или ваш Mac, или ваш телефон довольно быстр. И хотя Скретч здоровается и говорит ответ, как отмечает Натали, ответ звучит ошеломляюще, потому что я даже не остановилась. Так что я мог войти и найти блок - есть блок ожидания, который позволяет мне вставить произвольную паузу. Но я очень хочу, чтобы это было на одном дыхании. Я хочу, чтобы это было "привет", Дэвид, запятая, сразу.

Так как я могу это сделать? Что ж, позвольте мне пройти по Шефу. Оказывается, здесь есть множество вещей, связанных с математикой, а также кое-что, связанное с английским или другим языком. Присоединяйтесь к яблочному банану. Теперь это не имеет отношения к яблокам и бананам. Это просто заполнители, но здесь есть кусочек головоломки, который я могу перетащить. И знаешь, что? Позвольте мне сделать это. 

Позвольте мне заменить первый ввод, чтобы сказать, и позвольте мне присоединиться к приветственной запятой, а затем не банан, но позвольте мне перетащить ответ - и обратите внимание, что он встанет на место. Позвольте мне выбросить этот другой блок. Чтобы удалить вещи, вы можете просто перетащить их влево и отпустить. А теперь обратите внимание, что у меня есть программа, которая спрашивает, как вас зовут, а затем я скажу результат присоединения и отвечу.

И позвольте мне сыграть в это сейчас, после того, как я остановил старую. Как тебя зовут? Я ввожу Дэвида, вхожу и вуаля. Как замечает Натали, теперь он не спотыкается о себе, забивая то, что было раньше. Теперь я получаю все на одном дыхании. 

Теперь программа становится немного интереснее, но парадигма не отличается от прежней. На самом деле, позвольте мне предположить, что все, что мы только что сделали, идеально вписывается в всю эту ментальную модель того, что значит решать проблемы и что такое информатика. Так, например, если это проблема, которую необходимо решить, и у меня есть входы и выходы, моя цель и промежуточный алгоритм, давайте посмотрим, как Scratch даже вписывается в эту ментальную модель.

Моим вкладом в самую первую программу, которую мы написали минуту назад, было буквально «привет», мир в собственном овале. Алгоритм был реализован в Scratch как функция под названием say. Итак, алгоритм, пошаговые инструкции, функция - это компьютерная реализация алгоритма. В этом случае функция с именем say. На выходе, конечно же, кот здоровается, мир. 

Но сейчас все стало еще интереснее после замечания Натали, когда я представляю что-то вроде вопроса, как вас зовут, а затем подождите, обратите внимание, что на этот раз происходит в модели. Теперь проблема заключается в том, как вас зовут - это строка, которая идет по умолчанию, и я мог бы ее изменить, но не стал. Теперь это загружается в блок запроса. И блок запроса '

Этот ответ интересен, потому что теперь я могу присоединиться к нему со словом hello в качестве префикса. Итак, этот блок интересен, потому что обратите внимание, вход, белый овал блока say на самом деле имеет еще одну часть головоломки, а затем еще две части головоломки поверх нее. И что здесь круто, так это то, что при программировании функций вы можете сделать так, чтобы выходы одной функции становились входами для другой функции. 

Итак, поток здесь очень прост. Теперь у меня есть два входа для функции: привет, который я написал, и ответ, который пришел из блока запроса. Рассматриваемый алгоритм - это функция соединения, которую я только что использовал. И его вывод, надеюсь, будет привет, запятая, Дэвид.

Но я не хочу видеть на экране белый овал, передающий привет, запятая, Дэвид. Я хочу, чтобы кот поздоровался, запятая, Дэвид. Так что позвольте мне продолжить и сосредоточиться только на результатах. Сделайте его входом в финальную функцию, которая называется block, и вуаля, теперь кошка говорит то, что я хочу. 

Итак, опять же, даже когда вы начинаете вложение, то есть кладете эти кусочки головоломки друг на друга, все, что мы делаем, - это передача входных данных и получение выходных данных. Что-то делать с этими выходами и делать их входами и так далее. Это действительно парадигма того, что значит программировать.

Но мы можем заставить кошку делать более интересные вещи. И просто чтобы немного повеселиться, позвольте мне продолжить и покопаться в этом нижнем значке в нижнем левом углу экрана. У Scratch есть так называемые расширения, с помощью которых вы действительно можете заставить его делать более интересные вещи. И позвольте мне перейти к преобразованию текста в речь вверху справа. 

Итак, это использование облачной службы, то есть некоторой интернет-службы, которая будет отправлять слова, которые я печатаю в Интернете. Интернет, какой-то там сервер, сейчас ответит вербализацией того, что я только что набрал. Так что позвольте мне попробовать это. Позвольте мне избавиться от фиолетовой функции say и заменить ее этим блоком речи. И позвольте мне перетащить сюда кусок головоломки соединения - обратите внимание, что он будет расти, чтобы заполнить, и я больше не собираюсь использовать его.

На этот раз я собираюсь нажать «Стоп», а затем еще раз нажать «Воспроизвести» и ввести свое имя. И ... 

КОМПЬЮТЕР: (ЖЕНСКИЙ РОБОТИК) Привет, Дэвид. 

ДЭВИД ДЖ. МАЛАН: Хорошо, не очень естественный кошачий звук, но заметьте, мы можем настроить голос по-другому. Заметьте, я могу перетащить этот кусок пазла. И вы даже можете втиснуть блоки внутрь других. Обратите внимание, что он может идти куда угодно. Я поставлю его здесь на самом верху. Так что я мог бы поместить его в пару разных мест. Прямо сейчас голос по умолчанию - альт. Писк звучит уместно. Давай попробуем. Набираю мое имя, Дэвид. 

КОМПЬЮТЕР: (ВЫСОКО) Привет, Дэвид. 

ДЭВИД ДЖ. МАЛАН: Хорошо. По-прежнему не очень по-кошачьи. По иронии судьбы, есть голос котенка, который, если я поменяю его на котенка, мы теперь его услышим. Введите мое имя и войдите.

КОМПЬЮТЕР: (ВЫСОКО) Мяу-мяу. 

ДЭВИД ДЖ. МАЛАН: Хорошо, в этот момент не имеет значения, что я набираю. Но теперь это потрясающе. Типа, мы перешли от простого приветствия, мир к привету, Дэвид, который динамично меняется. Если бы вы набрали свое имя, очевидно, вместо этого было бы ваше имя. И теперь, благодаря облаку, то есть серверам в Интернете, мы автоматически конвертируем текст, который только что предоставил человек, в звуковой файл - ноты, длительность и все такое - во что-то, что теперь может воспроизвести мой компьютер. .

Что ж, давайте на самом деле сделаем так, чтобы эта кошка походила на кошку. Позвольте мне пойти дальше и избавиться от этих блоков здесь, и позвольте мне уйти и отдать себя сейчас из категории звука, как насчет этого? Играйте, пока не закончите. Итак, это простая программа. При щелчке по зеленому флажку воспроизводите звуковое мяу, пока не закончите. Вот так. Я собираюсь нажать «Играть». 

[MEOW] 

Хорошо, вот и все. Если я хочу снова услышать кошачье мяуканье, я должен сделать это снова. 

[MEOW] 

Хорошо, это здорово. Я мог бы немного развлечься, просто щелкнув - 

[МЯУ] - 

играть, но - 

[МЯУ] - 

конечно, мы можем добиться большего успеха, чем это. Вы можете себе представить, что это - 

[МЯУ] - 

быстро становится утомительным.

Так как же мне заставить кошку делать это снова и снова? Ну знаете что? Позвольте мне продолжить и позвольте мне взять несколько из них. Мяу, мяу, мяу, три раза. Так что теперь мне нужно нажимать кнопку в два раза меньше. 

[БЫСТРО МЯКАЕТ ТРИ РАЗА] 

Хорошо. Это не похоже на самую счастливую кошку. Так что позвольте мне на самом деле перейти к Control и дать ему второй перерыв между ними. Подождите одну секунду здесь. А теперь позволь мне сделать это снова. 

[ТРИ РАЗА МЯГАЕТ]

Ладно, кот немного счастливее. Но сейчас это кажется немного запутанным. Это правильно. Мяукает три раза. Но позвольте мне пойти в зал. Теперь рассмотрим дизайн. Напомним, что мы рассматривали дизайн в контексте телефонной книги. Третий алгоритм был лучше спроектирован, поскольку он был быстрее и эффективнее, но есть еще один элемент, который нужно разработать, а именно то, что вы не должны повторяться, если это возможно. Так что те из вас, кто программировал раньше, могут знать, какое здесь может быть решение.

Что ж, получается, что возвращаясь к третьей строке, мы вызываем цикл. Оказывается, Scratch поддерживает такие вещи, которые называются циклами. И, вообще-то, прямо здесь на меня смотрит один. Если я увеличу масштаб слева, обратите внимание, что под блоками управления, этими оранжевыми блоками, есть повторяющийся блок. И хотя по умолчанию указано 10, я уверен, что мы можем это изменить. Так что позвольте мне перетащить это сюда. Позвольте мне отбросить большую часть этой избыточности, этой копировальной пасты. Позвольте мне переместить эти части пазла внутрь повторяющегося блока, и он тоже вырастет, чтобы соответствовать им. Не проблема. Позвольте мне изменить повторение на три. А теперь позвольте мне все переподключить. 

А теперь программа просто ужесточилась. Он использует меньше кусочков головоломки или меньше строк кода, меньше шагов, если хотите, для достижения того же результата. Итак, теперь, если я нажму на зеленый флаг ...

[ТРИ РАЗА МЯКАЕТ] - 

он все еще работает. Таким образом, вы можете представить, что измените это на любое число, которое захотите. Есть даже вечный блок, где мы могли бы делать это вечно, если кошка собирается делать это вечно. Но теперь это лучшая программа. Теперь он лучше спроектирован, потому что, если я хочу изменить количество времени, в течение которого кошка ждет, или если я хочу изменить общее количество раз, когда кошка мяукает, я могу изменить эти детали в одном месте, а не в одном или двух или три, например, путем копирования и вставки тех же частей головоломки.

А что насчет этой бесконечной петли? Что, если вы действительно хотите что-то делать навсегда? Что я могу сделать? Что ж, давайте поднимем кошку и пошевелимся. Теперь позвольте мне перейти в категорию движения. Позвольте мне указать на указатель мыши. Так что позвольте мне увеличить это. И каждый раз, когда кошка указывает на указатель мыши, давайте заставим его сделать один шаг. Итак, я собираюсь сделать ход на несколько шагов, и я собираюсь заменить 10 на один. 

А теперь я нажимаю "Играть". И теперь у нас есть первая программа, в которой кошка как бы реагирует на курсор моего Mac. И я могу его двигать, и я могу немного пошутить, но это меня буквально берет. Он указывает на курсор мыши и затем перемещается на один шаг.

Теперь я могу заставить его двигаться быстрее. Позвольте мне на секунду остановиться. Что, если я буду двигаться не на один шаг за раз, а на два шага за раз? И мы увидим, что теперь кошка движется немного быстрее. Не совсем супер быстро. Давайте сделаем 20 шагов за раз и посмотрим, что получится. И в этом действительно суть анимации. Чем больше вы регулируете количество шагов или количество изменений, происходящих с этими пикселями в секунду или за единицу времени, тем больше будет происходить визуально на экране.

Ну, а что еще мы можем сделать, просто следуя? Ну знаете что? Если теперь у меня есть возможность заставить кошку следовать за мной, позвольте мне попробовать что-нибудь еще. Позвольте мне открыть другое расширение. Позвольте мне перейти к инструменту «Перо», который позволит мне теперь рисовать карандашом или ручкой на экране. И позвольте мне идти вперед, и я думаю, что кошка по-прежнему будет следовать за мной ... на самом деле, знаете что? Давай изменим это. 

Давай просто заставим его пойти туда, где я. Итак, есть еще один блок, который говорит перейти в случайную позицию. Я не хочу этого. Итак, я собираюсь изменить его здесь с помощью маленького треугольного меню, чтобы перейти к указателю мыши. Так что теперь, навсегда, кошка просто пойдет туда, где находится указатель мыши. Он не будет скользить или делать это медленно или быстро. Он просто переместится туда, где находится курсор.

А теперь позвольте мне перейти к этой новой категории Pen внизу. И как я могу это сделать? Ты знаешь что я хочу? Я хочу, чтобы этот кот умел за меня рисовать. Когда я перемещаю курсор вверх, вниз, влево, вправо, я хочу нарисовать что-то чернилами на экране. Но я хочу рисовать только тогда, когда перо опущено. Обратите внимание на то, что две из двух частей головоломки, которые я только что представил здесь слева, перо вниз и ручка вверх. 

Но здесь есть часть недостающей логики. Позвольте мне спросить аудиторию, как мы можем улучшить эту программу, чтобы кошка не только следила за моим курсором, но и рисовала на экране? Николас, какие решения вы бы предложили?

АУДИТОРИЯ: Итак, что вы могли бы сделать, это взять оператор if, чтобы вы могли контролировать, когда перо поднято или когда перо опущено, в зависимости от вашего состояния. Мол, я много чего знаю, вы рисуете щелчком мыши, если мышь включена, вы можете сказать, что перо опущено. И когда щелчок мышью не включен, ваше перо поднято. И затем, пока он следует за ним вечно, он также чувствует, включен или выключен ваш щелчок мышью. Я действительно не знаю. 

ДЭВИД ДЖ. МАЛАН: Нет, вы действительно знаете. Это было идеально. Поскольку вы взяли этот принцип, согласно которому блок forever не только перемещается к указателю мыши, вы предложили задать вопрос по условию.

Так что позвольте мне на самом деле перейти под контроль, где я случайно знаю эту часть головоломки, и обратите внимание на псевдокод нашей телефонной книги, где я сказал, если еще, если еще, если еще, ну, здесь есть только два вопроса, я думаю, как вы предлагаете. Кнопка мыши нажата или поднята? Так что я думаю, что нам сойдет с рук только «если». 

Так что позвольте мне перетащить это ниже курсора мыши. А затем обратите внимание на эту маленькую трапециевидную форму посередине. Позвольте мне перейти к Sensing здесь. И обратите внимание, если я прокручу вниз - да, вот оно. Слева заметили это? Мышь вниз, вопросительный знак? Это наши логические выражения. Позвольте мне перетащить это логическое выражение в аналогичную фигуру. Он будет расти, чтобы соответствовать этому.

И что тогда я хочу делать? Если мышь опущена, я думаю, что хочу положить перо. В противном случае, если мышь неявно поднята, позвольте мне пойти дальше и поднять перо вот так. Что ж, позвольте мне перейти к полноэкранному режиму, чтобы мы могли видеть немного лучше. Дайте мне нажать "Играть". И вот кот, как и обещал, преследует меня. Но теперь это рисунок кота. Если я нажму кнопку мыши, я могу сказать что-то вроде "Привет", очень плохо прописью. Вроде, как бы, что-то вроде. Прошло много времени с тех пор, как я написал курсив.

Итак, теперь у нас есть кот, который что-то рисует. И, честно говоря, немного смешно, что это рисунок кошки. Но вы знаете, что? Эти костюмы есть у Скретча. Мы могли бы пойти сюда в верхнем левом углу, и хотя Scratch поставляется с двумя костюмами кошек, мы можем изменить их на ручку или маркер или, на самом деле, на что угодно. Потому что, в конце концов, этот спрайт на самом деле просто персонаж на экране, который может принимать любую форму, которую мы можем пожелать.

Что ж, как мы можем продвинуться дальше? Мне нравится это введение условий и циклов, но есть и другие принципы, которые мы можем здесь ввести. Позвольте мне начать здесь совершенно новую программу. И давайте посмотрим, не сможем ли мы начать отсчет и начать отслеживать информацию. Итак, на этот раз давайте сделаем это. Когда щелкнут зеленый флажок, на этот раз перейдем к переменным и дадим себе новую переменную. Scratch позволяет создавать кусочки пазла, причем этот элемент является переменной, и я назову его счетчиком. Просто то, что будет вести счет от одного до другого.

Теперь это дало мне несколько нестандартных кусочков головоломки, называемых счетчиком, а затем мою переменную по умолчанию, которая уже была там. И я собираюсь сделать это. Я собираюсь изначально установить счетчик равным единице. И тогда я собираюсь что-то делать навсегда. Позвольте мне взять один из тех блоков навсегда. И я хочу, чтобы кот теперь делал это вечно. Я хочу просто сказать, каков текущий счет. Так что я не хочу, чтобы он здоровался на две секунды. Я хочу, чтобы он что-то сказал, скажем, на одну секунду.

Итак, я вернусь к переменным. И я собираюсь взять эту новую круглую форму, счетчик, которую я создал, и перетащить ее прямо туда. Так что вы можете читать это буквально сверху вниз. Так что против единицы, затем навсегда скажите счетчик на одну секунду. Но если мы не хотим, чтобы кошка повторяла одно и то же число снова и снова, давайте изменим счетчик на единицу. И это неявно добавит один к счетчику. 

Теперь, если я нажму «Играть», мы увидим кошку, которая считает от одного до двух до трех, и, в идеале, она будет считать до бесконечности. Разница в том, что теперь у нас есть функция фактического использования переменной, переменной, которая отслеживает некоторый объем информации. В этом случае номер, который постоянно обновляется,

Что ж, теперь позвольте мне продолжить и просто начать открывать несколько программ, которые я написал заранее, просто чтобы мы могли ознакомиться с некоторыми из них. У меня есть программа под названием Bounce, которая работает примерно так. И это тоже часть программирования. Не только написание собственного кода, но и чтение собственного кода. И позвольте мне продолжить и увеличить это, которое я уже создал, и подумать о том, что в нем говорится.

Первый набор, стиль вращения, влево, вправо. Это просто исправление того, что в противном случае было бы ошибкой, когда кошка случайно оказывается вверх ногами. Но позвольте мне помахать рукой. Это интересная часть. Навсегда кошка перешла на 10 шагов. А затем, если он касается края, поверните на 180 градусов. Итак, теперь мы можем заново представить идею анимации. Но не мной, человеком, с моим курсором. Теперь я могу создать игру, интерактивное произведение искусства или что-нибудь еще, где кошка ведет себя самостоятельно. 

Потому что, когда я нажимаю «Играть сейчас», замечаю, что он движется вперед-назад, вперед-назад. И если он касается края, и ответ на этот логический вопрос, на самом деле, да, истина или единица, то он повернется на 180 градусов.

Но, надо признать, это выглядит глупо. Знаете, один, кот, да, отскакивает от экрана, что, может быть, немного нереально. Но на самом деле он не ходит. Он скользит. Но в этом суть анимации. Как мы уже отмечали ранее, видео, в конце концов, на самом деле представляют собой просто изображения, летающие по экрану - знаете что? Бьюсь об заклад, мы можем создать нашу собственную иллюзию движения, как в реальном видео, взяв не один костюм, а кошку с ногами вот так.

Что, если мы дадим себе второй костюм, где он почти такой же, но его ступни немного по-другому расположены? Точно так же, как бумажный флипбук, который мы рассматривали ранее. И знаешь, что? Готов поспорить, если я буду переключаться между этими двумя костюмами, снова и снова меняя состояние кошки, я уверен, что мы сможем создать иллюзию реального движения.

И это то, что мы имеем в этом другом примере отскока. В этом другом примере отскока кошка теперь движется не только вперед и назад, но и обратите внимание на этот фиолетовый кусочек пазла. После того, как он отскакивает от края или решает отскочить от края, он постоянно меняет свой костюм на следующий, на следующий, на следующий, по существу, чередуя их. Так что теперь это не совсем идеально. Мол, у него то, что мы называем очень низкой частотой кадров. Это похоже на просмотр в сети действительно плохого анимированного GIF-файла, в котором всего два разных кадра. Но это больше похоже на то, что он ходит, а не на то, что он скользит взад и вперед по экрану. 

Так что мы тоже можем немного повеселиться. Звуки поддержки царапин. Так, например, вот мяу, которое мы слышали раньше. 

[МЯУ]

Однако я могу записать свои собственные, если щелкну этот маленький значок плюса здесь. Нажмите «Запись» и разрешите Scratch получить доступ к моему микрофону. Нажмите кнопку ОК пару раз. Вот так. Позвольте мне записать свой голос. Ой. Все в порядке. Вот как выглядит слово Ой, по крайней мере, когда я его произносю. Я могу обрезать начало здесь. Позвольте мне сохранить это. Я собираюсь дать этой записи имя, Ой, а теперь позвольте мне вернуться к своему коду. 

А под звуковым блоком знаете что? Позвольте мне сказать следующее. Если я касаюсь края, я не только хочу повернуться на 180 градусов. Теперь я могу немного поиграть. 

КОМПЬЮТЕР: Ой. Ой. Ой.

ДЭВИД ДЖ. МАЛАН: Хорошо. Все еще не очень по-кошачьи, но опять же, мы просто наслаиваем и складываем слои. И вывод здесь действительно таков: поскольку эти программы становятся все более и более сложными, цель никогда не должна состоять в том, чтобы при написании кода, будь то на Scratch или C или, в конечном итоге, на Python в этом или другом классе, просто начать и попытаться реализовать всю вашу зрение. Обратите внимание, что для каждой из этих программ, которые я написал с нуля, без каламбура, я начал с малого и добавил одну, две или три части головоломки, выстраиваясь от чего-то простого к чему-то более сложному.

И знаешь, что? Бьюсь об заклад, если мы синтезируем некоторые из этих идей, мы сможем сделать и другие вещи. Вот еще один пример, связанный, возможно, с глажением кошки. Позвольте мне заглянуть внутрь этой программы. Это относительно просто, но пока ничего не делает. Я уже попал в зеленый флаг. Позвольте мне увеличить масштаб кода, и вы, возможно, теперь сможете прочитать мой собственный код, который я написал заранее. Кошка постоянно задает вопрос, если дотронуться до указателя мыши, проиграйте это звуковое мяуканье, пока не закончите. 

Что ж, казалось бы, программа хоть и запущена, но ничего не делает. Но это. Он ждет, чтобы что-то случилось. Так что позвольте мне 

навести курсор на кошку, как ... [МЯУК] - вот 

. 

[МЯУ]

Казалось бы, и если я оставлю это там, он продолжит мяукать. И это вроде программы, которая гладит кошку. Итак, вы можете представить себе условия внутри циклов, которые используют логические выражения, чтобы точно решить, что вы хотите сделать. 

И даже более эффективно, даже на таком языке, как Scratch, мы можем это сделать. Позвольте мне открыть здесь морского льва, у которого очень отчетливый лай. Но теперь он демонстрирует программу, в которой есть несколько скриптов. Итак, внутри этого проекта Scratch сейчас мы не одна программа, а две. Обратите внимание, что оба из них запускаются при щелчке по зеленому флажку. И позвольте мне поместить их обоих на экран. И выглядит дольше. Но это только потому, что части пазла растут, чтобы соответствовать друг другу. Давайте продолжим и нажмем "Играть" на этом.


Обратите внимание на то, что морской лев лает примерно каждую секунду. И, честно говоря, это быстро надоедает. Но как мне это остановить? Что ж, позвольте мне пойти и посмотреть сюда слева, пока он все еще лает. Заметьте, морской лев постоянно задает вопрос. Если отключение звука равно false, запускается звуковой сигнал морского льва, подумайте «привет, привет, привет» в течение двух секунд. Так что отключено? Напомним, что его форма представляет собой переменную, такую ??как x, y или z, которая является лишь некоторым способом сохранения информации. Это все равно что сказать, является ли значение отключенной переменной ложным? Если это так, вы должны лаять, потому что, если он отключен неверно, если он не отключен, включите звук морского льва.

Но, боже мой, давай ... Обратите внимание, что справа есть еще одна программа. Когда щелкают зеленый флажок, навсегда задайте вопрос. Если нажата клавиша пробела, то, если приглушено значение true, установите для параметра «Приглушенный звук» значение «ложь», в противном случае установите для параметра «Приглушение» значение «истина». Таким образом, программа справа изменит значение приглушенного звука с false на true или true на false. Потому что, боже мой. Я нажал пробел ... 

[ ЛАЙ МОРСКОГО ЛЕВА] 

И теперь все кончено. Программа все еще работает, но больше не воспроизводится, потому что отключение звука теперь истинно, а не ложно.

Ну что еще мы можем сделать? Довольно быстро все может стать довольно необычным. Позвольте мне продолжить и создать здесь еще одну программу. И я сделаю один всего с двумя блоками. Этот - позвольте мне снова перейти к расширениям, на этот раз с видеосенсором, и заметить, что есть разные способы запуска программ. Не каждая программа должна запускаться при нажатии на зеленый флаг. Здесь есть похожая форма, но эта зеленая, которая говорит, что движение видео больше 10. Примерно 10% экрана движется. Позвольте мне увеличить это до 50%. 

И позвольте мне сделать это. Позвольте мне найти кусочек звуковой головоломки. Играйте, пока не закончите. Итак, теперь у меня есть двухблочная программа. Когда количество движений в видео превышает 50, воспроизводите звуковое мяу, пока не закончите.

Позвольте мне уменьшить масштаб. И вы заметите, что я на самом деле здесь на экране. Позвольте мне уйти со сцены. А сейчас ничего не происходит. Но позволь мне пойти погладить кошку. 

[MEOW] 

Позвольте мне сделать это еще раз. 

[МЯУ] 

И снова. Итак, он использует камеру моего компьютера - 

[MEOW] - 

обнаруживает движение, а затем выполняет эту конкретную программу. 

Итак, опять же, с помощью этих простых строительных блоков можем ли мы получать все больше и больше интересных вещей. И знаешь, что? У нас даже может быть несколько спрайтов. Позвольте мне продолжить и открыть старую школьную игру, в которую вы, возможно, играли, например, в бассейне, возможно, росли, когда один человек кричит Марко, а другие должны кричать Поло.

Обратите внимание, что у нас есть программа с двумя спрайтами. Итак, две марионетки, оранжевая и синяя марионетки. И вот здесь, внизу, впервые у нас есть два разных спрайта, способных писать программы. Итак, прямо сейчас оранжевая марионетка выбрана, что означает, что программа в верхнем левом углу здесь, наверху, принадлежит оранжевой марионетке. А оранжевая марионетка запрограммирована так, чтобы говорить «вечно», если на клавиатуре нажата клавиша «пробел», затем на две секунды произносить «Марко». 

А вот и новая функция. В программировании есть способ, чтобы одна программа разговаривала с другой, или, в данном случае, один спрайт разговаривал с другим. Что-то вроде передачи секретного сообщения, которого вы не видите на экране. Но одна программа может слышать от другой. И это называется трансляцией события. И это то, что делает оранжевая марионетка.

Если я щелкну здесь значок с синей марионеткой, он вообще не будет делать очень много. Но вместо того, чтобы делать что-либо при щелчке по зеленому флажку, вместо того, чтобы что-то делать, когда камера видит движение, он вместо этого собирается, когда он получает событие, скажет Polo в течение двух секунд. 

Итак, в этом случае, если я нажму «Играть сейчас», еще ничего не произойдет. Но когда я нажимаю пробел, оранжевый говорит Марко, синий - Поло. Но они пишутся самостоятельно. Я написал одну программу для оранжевого, одну программу для синего, и они как-то общаются.

Говоря об общении, в наши дни вы можете делать еще больше благодаря Интернету и облаку. Позвольте мне открыть здесь еще одно новое полотно. Очень быстро завожусь, когда щелкают зеленый флажок. Позвольте мне продолжить и задать тот же вопрос раньше, спросите, как вас зовут, и подождите. Но теперь позвольте мне войти в эти расширения и позвольте мне найти расширение translate, которое, опять же, будет использовать облако для отправки всего, что я набираю в Интернете, и получения ответа, а затем произнесите это на экране здесь .

Так что позвольте мне сказать что-нибудь на экране, например, поздороваться. Но я не хочу здороваться. Я хочу вернуться в категорию "Переводчик" и продолжить перевод - знаете что? Мне нравится этот блок. Переведите что-нибудь на другой язык. Но позвольте мне снова получить один из этих блоков соединения, и позвольте мне присоединиться к слову "привет", а затем к имени, которое набрал человек. Итак, чтобы получить это, мне снова нужен блок ответов. Так что я просто воссоздаю некоторые из наших блоков ранее.

И обратите внимание, до того, как я только что это сделал. Я сказал результат присоединения к приветствию и ответу, правда, в прошлый раз с запятой. Но теперь займемся этим. Позвольте мне взять вывод соединения, сделать его вводом для перевода. Позвольте мне здесь перевести, скажем, на арабский. Позвольте мне перетащить в блок say. Итак, теперь у нас есть два входа, идущих в join, выход join - вход translate, а выход translate - say. 

Но в конечном итоге я наберу свое имя Дэвид и нажму Enter. Привет, Дэвид, теперь на арабском. Все благодаря этим принципам функций, условий и циклов, а теперь даже добавлению в Интернет.

Теперь давайте рассмотрим окончательно, прежде чем сыграем в последнюю пару игр. В заключение, есть способ даже улучшить дизайн многого из того, что мы сделали. На самом деле, позвольте мне вернуться на минутку к тому месту, где мы остановились этим мяуканьем. И в одном из наших примеров мяуканья у нас был код, который выглядел примерно так, где я повторял три раза, вспомните, и воспроизводил звуковое мяуканье снова и снова и снова. 

И в то время я утверждал, что это лучше спроектировано. Почему? Потому что я не просто перетаскивал один и тот же кусок пазла снова и снова и снова. Я использовал повторный блок, я отбросил всю избыточность и, возможно, сохранил его простым. Я использую несколько более причудливых идей, но код проще, и теперь в нем меньше кусочков головоломки.

Но оказывается, что здесь упущена возможность применить другой принцип информатики, и это то, что мы обычно называем абстракцией. Абстракция - это удивительный метод решения проблем, который на самом деле просто причудливый способ сказать: давайте возьмем очень сложную идею или немного сложную идею и упростим ее таким образом, чтобы мы все согласились с тем, что вы можете реализовать ее сложным способом, но давайте теперь просто укажите, что мы будем думать об этом на более простом уровне.

Так что позвольте мне перейти к той же программе. И знаешь, что? Любопытно, что Скретч не ожидал, что у него будет мяуканье. Например, есть блок say и есть блок think, но нет блока мяу. И это кажется подходящим для программы, в которой есть встроенный кот. Итак, мы можем это сделать. Обратите внимание, что так же, как вы можете создавать свои собственные переменные, вы можете создавать свои собственные блоки с этой розовой категорией. 

И если я пойду сюда, я сделаю блок и назову этот блок мяуканьем. И очень просто, я собираюсь нажать ОК. А теперь обратите внимание, что я получил этот новый кусок головоломки с надписью «Определите мяу». И он готов к подключению других частей. Как я буду определять мяу? Я просто собираюсь перетащить это сюда, потому что я уже реализовал мяу раньше.

А теперь обратите внимание на то, что у меня слева. Поскольку я только что сделал этот нестандартный блок или кусок пазла, у меня теперь есть розовый кусок, который называется мяу, как если бы он был в Scratch. И вот что меня привлекает, так это то, что я могу думать об этом как об этом, вне поля зрения, вне головы. Какая разница, как реализовано мяуканье? Мы знаем, что реализовали это раньше. Давайте теперь просто оговоримся, что мы можем считать само собой разумеющимся, что он существует. 

И если я сейчас увеличу масштаб новой программы, теперь она в некотором смысле более читабельна. Это немного короче. В нем меньше кусочков пазла. Но он также более информативен. Я могу прочитать свой код. Я могу посмотреть на этот код и сказать: «Хорошо, очевидно, что он будет повторяться три раза в блоке мяуканья». Но давайте поиграем в это. 

[MEOW] 

Ничего особенного.



[MEOW] 

Но я уверен, что мы можем упростить этот шаг еще больше и сделать его более гибким. Позвольте мне продолжить и щелкнуть правой кнопкой мыши или нажать кнопку Control на настраиваемом блоке мяу. И позвольте мне добавить сюда ввод, который мы назовем n. И позвольте мне просто добавить метку с указанием времени. И позвольте мне продолжить и нажать ОК. И обратите внимание, что моя часть пазла теперь выглядит иначе. Это больше похоже на некоторые блоки Массачусетского технологического института, которые вводят данные с помощью этих маленьких белых овалов.

И, собственно, теперь обратите внимание на то, что я могу сделать. Я могу изменить определение мяуканья, как это уже сделал для меня Скретч, так что теперь я могу делать больше внутри. Позвольте мне отключить все это. Позвольте мне переместить блок повтора к самому определению мяу. Позвольте мне воспроизвести звук и подождать внутри этого блока повтора, но обратите внимание на этот маленький кружок на конце. Позвольте мне сейчас просто повторить произвольное количество раз. Мне не нужно беспокоиться о жестком кодировании трех, десяти или чего-то еще.

А теперь, вне поля зрения, из виду, больше не о чем беспокоиться. Давайте теперь просто сократим эту усложняющуюся программу, которую мы написали ранее, на самом деле, всего в два кусочка головоломки. При щелчке по зеленому флажку мяукать, конечно, три раза. Мне больше не нужно знать или беспокоиться о том, как реализовано мяу. Мне просто нужно знать, что кто-то сделал это за меня, будь то Массачусетский технологический институт или, может быть, я несколько минут назад. Я снова нажму "Играть". 

[ТРИ РАЗА МЯКАЕТ] 

Два и три. Итак, теперь у нас есть реализация абстракции. Возьмем несколько сложную идею, например, заставим кошку мяукать, не беспокоясь о так называемых деталях реализации, и просто определим кусок головоломки или функцию, называемую мяу.

Что ж, теперь давайте возьмем все это вместе и посмотрим на некоторые творения некоторых из ваших предшественников в прошлом. Вот, например, история, которую один из ваших одноклассников много лет назад сочинил на основе имбирного пряника. Позвольте мне перейти к полноэкранному режиму и нажать Play. 

[ИГРАЕТ МУЗЫКА] 

И теперь вы увидите, что у нас уже есть несколько спрайтов, каждый из которых имеет разные костюмы, и мне задают вопрос. Ты хочешь яблоко? Да или нет. Так что меня больше не спрашивают, как меня зовут. Мне задают произвольные вопросы. Конечно. Позвольте мне пойти и съесть яблоко. Я набираю да и нажимаю Enter. 

Обратите внимание на движение. Мы уже видели движение. 

[ЗВУКИ] [ИГРАЕТ 

МУЗЫКА]

Хорошо, к сожалению, это было неправильное решение в этой истории. Так что все в порядке. Начнем снова. Красный знак остановки. 

[ИГРАЕТ МУЗЫКА] 

Зеленый флаг. Привет, дорогая, хочешь яблоко? Нет, давайте извлечем уроки из этого урока. Кекс звучит намного лучше. Я напечатаю "да" на этот раз. Обратите внимание на движение. Так что там есть анимация. Он касается другого спрайта. Это тоже было прискорбно. Давайте в последний раз попробуем это искусство. 

А теперь у нас есть яблоко, нет. Выучил урок. Кекс, нет. Выучил урок. Хорошо, теперь давайте посмотрим, что происходит с этим циклом. 

[СМЕШИВАНИЕ] 

[КРИК] 

[ЗВУКИ]

Хорошо, неожиданный финал. Но это все, чтобы сказать, что, взяв эти строительные блоки циклов, условий и функций, вы можете начать делать вещи немного более интерактивными. 

Фактически, я сам сделал кое-что много лет назад - самое первое, что я сам написал в Scratch, было на самом деле, когда я учился в аспирантуре и зарегистрировался на курс в Массачусетском технологическом институте, профессор которого был автором и создателем Поцарапайте себя. И позвольте мне пойти дальше и показать это в полноэкранном режиме и предложить, как я думал о решении довольно большой проблемы в те дни.

Перетащите в корзину как можно больше падающего мусора. Так что же сейчас происходит? На экран падает кусок мусора. Вы увидите, что он движется сверху вниз, и мы видели такую ??анимацию. Но посмотри на это. Бьюсь об заклад, используя условие и цикл forever, мы можем сделать это возможным. Обратите внимание, теперь мусор следует за моим курсором, как и кошка. И обратите внимание, если прикоснуться к этому другому спрайту из мусорной корзины, возможно, мы даже сможем заставить Оскара выскочить из банки. Затем он начинает подсчитывать мой счет, тем самым используя переменную, и действительно, когда падает больше спрайтов или больше мусора, я могу продолжать играть в игру таким образом.

Но и здесь, несмотря на то, что все начинает происходить быстрее, на экране появляется больше, песня играет в фоновом режиме, все сводится к основным строительным блокам. И я не могу выделить достаточно. Когда я писал эту первую программу много лет назад, я не реализовал то, что вы только что видели. Думаю, первым делом я погуглил, нашел уличный фонарь «Улицы Сезам» и повесил его на экран. И это была своего рода первая версия. Это ничего не дало, но похоже, что я хочу.

Потом добавил мусорное ведро. Тогда я думаю, что запрограммировал падение одного мусора или одного спрайта. Поэтому я превратил кота в мусор, а затем оживил его сверху вниз. Затем в четвертой или пятой версии я добавил бесконечный цикл и условие, которое проверяет, нажата ли кнопка мыши, и если да, то она должна следовать за указателем мыши. Поэтому я взял большую проблему и разбил ее постепенно на более мелкие шаги. 

И это был тот же подход, который использовал Эндрю Берри из CS50 много лет назад, один из наших преподавателей. В самый первый год, когда я преподавал CS50, он создал свой первый Scratch-проект, который, как я думал, оставлю нас здесь сегодня.

Это программа, которую он назвал Raining Men. Это может быть знакомая мелодия, и я предлагаю вам подумать, когда вы смотрите эту последнюю сегодняшнюю программу Scratch, как Эндрю программировал все, что вы видите.

Теперь Эндрю ушел в реальный мир и не стал заниматься информатикой как таковой. На самом деле он сейчас генеральный менеджер Cleveland Browns, американской футбольной команды. Но это тоже говорит о том, какую основу вы можете сформировать, независимо от вашей предполагаемой специальности, вашей возможной специальности, учитывая, в конце концов, что многие идеи, на которых мы собираемся сосредоточиться в этом классе, в конечном итоге связаны с решение проблем, программирование - лишь один из инструментов торговли. И действительно, даже в мире спорта сейчас так много возможностей для алгоритмов, анализа и видеомоделирования, и многие миры Эндрю и ваши миры неизбежно начнут сталкиваться, когда вы начнете создавать свои собственные. инструментарий и ваше собственное понимание этого.

Итак, в заключение, мы взглянем на эту программу Эндрюса. А пока это был CS50, а сейчас идет дождь мужиков. 

[МУЗЫКА - «МУЖЧИНЫ Дождь»] 

КОМПЬЮТЕР: Привет. 

Привет. 

Мы ваши метеорологи. 

Ага. 

У нас есть новости для вас. 

Послушайте лучше. 

Будьте готовы, все вы, одинокие девушки, и оставьте эти зонтики дома . 

Ладно. 

(ПОЕТ) Влажность растет, барометр падает. 

Ох. 

Ой. 

По всем источникам ... 

Какие источники сейчас? 

Это место, куда можно пойти по улице. Потому что сегодня вечером впервые, примерно в половине одиннадцатого. , впервые в истории начнется дождь из мужчин!

Идет дождь, мужики, аллилуйя, идет дождь, мужики ... 

[ ИГРАЕТ МУЗЫКА]
